<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VPAT: vpslice.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">source</a></div>
<h1>vpslice.cpp</h1><a href="vpslice_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">//  PROJECT.....: vpat - Creating Virtual Patients</span>
<a name="l00004"></a>00004 <span class="comment">//  RESPONSIBLE.: Carla Freitas e Luciana Nedel</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">//  FILE........: vpslice.cpp</span>
<a name="l00007"></a>00007 <span class="comment">//  DESCRIPTION.: Contain the VPSlice class implementation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">//  AUTHOR......: Isabel Harb Manssour</span>
<a name="l00010"></a>00010 <span class="comment">//  DATE........: October/04/2000</span>
<a name="l00011"></a>00011 <span class="comment">//  DESCRIPTION.: Constructors definition and methods implementation.</span>
<a name="l00012"></a>00012 <span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">//  AUTHOR......: Isabel Harb Manssour</span>
<a name="l00014"></a>00014 <span class="comment">//  DATE........: June/04/2001</span>
<a name="l00015"></a>00015 <span class="comment">//  DESCRIPTION.: Methods and parameters changes.</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment">//  AUTHOR......: Isabel Harb Manssour</span>
<a name="l00018"></a>00018 <span class="comment">//  DATE........: October/25/2001</span>
<a name="l00019"></a>00019 <span class="comment">//  DESCRIPTION.: Update for inner structure visualization.</span>
<a name="l00020"></a>00020 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;<a class="code" href="vpslice_8h.html">vpslice.h</a>&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;<a class="code" href="vpimage_8h.html">vpimage.h</a>&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;<a class="code" href="vpvolume_8h.html">vpvolume.h</a>&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;<a class="code" href="vpplane_8h.html">vpplane.h</a>&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;list&gt;</span>
<a name="l00030"></a>00030 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00034"></a>00034 <span class="comment">// Description: Class "VPSlice" constructor without parameter. </span>
<a name="l00035"></a>00035 <span class="comment">// Parameters.: -</span>
<a name="l00036"></a>00036 <span class="comment">// Return.....: -</span>
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="classVPSlice.html#a0">00038</a> <a class="code" href="classVPSlice.html#a0">VPSlice::VPSlice</a> () {
<a name="l00039"></a>00039     <a class="code" href="classVPSlice.html#p2">lineSBand</a> = <a class="code" href="RasDefine_8h.html#a0">NULL</a>;
<a name="l00040"></a>00040     <a class="code" href="classVPSlice.html#p3">lineTBand</a> = <a class="code" href="RasDefine_8h.html#a0">NULL</a>;
<a name="l00041"></a>00041     <a class="code" href="classVPSlice.html#p4">numTotalPoints</a> = 0;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00046"></a>00046 <span class="comment">// Description: Class "VPSlice" destructor. </span>
<a name="l00047"></a>00047 <span class="comment">// Parameters.: -</span>
<a name="l00048"></a>00048 <span class="comment">// Return.....: -</span>
<a name="l00049"></a>00049 
<a name="l00050"></a><a class="code" href="classVPSlice.html#a1">00050</a> <a class="code" href="classVPSlice.html#a1">VPSlice::~VPSlice</a> () {
<a name="l00051"></a>00051     <span class="keywordflow">if</span> (<a class="code" href="classVPSlice.html#p2">lineSBand</a> != <a class="code" href="RasDefine_8h.html#a0">NULL</a>) {
<a name="l00052"></a>00052         <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l00053"></a>00053         <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l00054"></a>00054     }
<a name="l00055"></a>00055 }
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 
<a name="l00059"></a>00059 <span class="comment">// Description: Method "vpTopSliceRender" implement the algorithm </span>
<a name="l00060"></a>00060 <span class="comment">//              to visualize one volume slice from the top.</span>
<a name="l00061"></a>00061 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00062"></a>00062 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00063"></a>00063 <span class="comment">//              to the image);</span>
<a name="l00064"></a>00064 <span class="comment">// Return.....: -</span>
<a name="l00065"></a>00065 
<a name="l00066"></a><a class="code" href="classVPSlice.html#a2">00066</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a2">VPSlice::vpTopSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00067"></a>00067  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00068"></a>00068      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00069"></a>00069      imageXdelta=0, imageYdelta=0, whiteLine=0, whiteColumn=0;
<a name="l00070"></a>00070  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0;
<a name="l00071"></a>00071 
<a name="l00072"></a>00072  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00073"></a>00073  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00074"></a>00074  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00075"></a>00075 
<a name="l00076"></a>00076  <span class="comment">// Set pointer to the volume object</span>
<a name="l00077"></a>00077  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00080"></a>00080  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00081"></a>00081 
<a name="l00082"></a>00082  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00083"></a>00083  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00084"></a>00084                 
<a name="l00085"></a>00085  <span class="comment">// Set projection direction by the vector</span>
<a name="l00086"></a>00086  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00087"></a>00087  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00088"></a>00088 
<a name="l00089"></a>00089  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00090"></a>00090  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00091"></a>00091 
<a name="l00092"></a>00092  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00093"></a>00093  up = camera-&gt;vpGetUp();
<a name="l00094"></a>00094  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00095"></a>00095  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00098"></a>00098  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00099"></a>00099  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00100"></a>00100 
<a name="l00101"></a>00101  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00102"></a>00102  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00103"></a>00103  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00104"></a>00104 
<a name="l00105"></a>00105  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00106"></a>00106  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00107"></a>00107  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00108"></a>00108     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00109"></a>00109     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00110"></a>00110     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00111"></a>00111  }
<a name="l00112"></a>00112  <span class="keywordflow">else</span> {
<a name="l00113"></a>00113     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00114"></a>00114     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00115"></a>00115     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00116"></a>00116  }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118  <span class="comment">// Window/Viewport ratio</span>
<a name="l00119"></a>00119  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00120"></a>00120  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122  <span class="comment">// Line, column and sample step </span>
<a name="l00123"></a>00123  deltaX = vectorH * ratioX;
<a name="l00124"></a>00124  deltaY = vectorV * ratioY;
<a name="l00125"></a>00125  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00126"></a>00126 
<a name="l00127"></a>00127   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00128"></a>00128   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00129"></a>00129 
<a name="l00130"></a>00130      <span class="comment">// Plane point computation</span>
<a name="l00131"></a>00131      p1 = minPlaneProjection;
<a name="l00132"></a>00132      p1 = p1 + deltaY * line; 
<a name="l00133"></a>00133 
<a name="l00134"></a>00134      <span class="comment">// Scan view column</span>
<a name="l00135"></a>00135      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         i = (int) (p1.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>()); <span class="comment">//(column);</span>
<a name="l00138"></a>00138         j = sliceNumber;         <span class="comment">//(line);</span>
<a name="l00139"></a>00139         k = (int) (p1.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>()); <span class="comment">//(depth);</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141         p1.<a class="code" href="classVPPoint3D.html#a13">vpSetY</a>(sliceNumber);
<a name="l00142"></a>00142         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="comment">// Next plane point computation</span>
<a name="l00147"></a>00147         p1 = p1 + deltaX; 
<a name="l00148"></a>00148 
<a name="l00149"></a>00149     } <span class="comment">// for (column)</span>
<a name="l00150"></a>00150 
<a name="l00151"></a>00151  } <span class="comment">// for (line)</span>
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 }
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00157"></a>00157 <span class="comment">// Description: Method "vpSideSliceRender" implement the algorithm </span>
<a name="l00158"></a>00158 <span class="comment">//              to visualize one volume slice from the side.</span>
<a name="l00159"></a>00159 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00160"></a>00160 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00161"></a>00161 <span class="comment">//              to the image);</span>
<a name="l00162"></a>00162 <span class="comment">// Return.....: -</span>
<a name="l00163"></a>00163 
<a name="l00164"></a><a class="code" href="classVPSlice.html#a3">00164</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a3">VPSlice::vpSideSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00165"></a>00165  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00166"></a>00166      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00167"></a>00167      imageXdelta=0, imageYdelta=0, virtualYDimension=0;
<a name="l00168"></a>00168  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, yCorrection=0;
<a name="l00169"></a>00169 
<a name="l00170"></a>00170  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00171"></a>00171  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00172"></a>00172  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174  <span class="comment">// Set pointer to the volume object</span>
<a name="l00175"></a>00175  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00178"></a>00178  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00181"></a>00181  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00182"></a>00182                 
<a name="l00183"></a>00183  <span class="comment">// Set projection direction by the vector</span>
<a name="l00184"></a>00184  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00185"></a>00185  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00186"></a>00186 
<a name="l00187"></a>00187  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00188"></a>00188  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00189"></a>00189 
<a name="l00190"></a>00190  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00191"></a>00191  up = camera-&gt;vpGetUp();
<a name="l00192"></a>00192  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00193"></a>00193  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00196"></a>00196  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00197"></a>00197  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00198"></a>00198 
<a name="l00199"></a>00199  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00200"></a>00200  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00201"></a>00201  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00202"></a>00202 
<a name="l00203"></a>00203  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00204"></a>00204  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00205"></a>00205  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00206"></a>00206     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00207"></a>00207     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00208"></a>00208     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00209"></a>00209  }
<a name="l00210"></a>00210  <span class="keywordflow">else</span> {
<a name="l00211"></a>00211     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00212"></a>00212     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00213"></a>00213     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00214"></a>00214  }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l00217"></a>00217  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l00218"></a>00218     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l00219"></a>00219  <span class="keywordflow">else</span> 
<a name="l00220"></a>00220     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l00221"></a>00221  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223  <span class="comment">// Window/Viewport ratio</span>
<a name="l00224"></a>00224  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00225"></a>00225  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227  <span class="comment">// Line, column and sample step </span>
<a name="l00228"></a>00228  deltaX = vectorH * ratioX;
<a name="l00229"></a>00229  deltaY = vectorV * ratioY;
<a name="l00230"></a>00230  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00233"></a>00233   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00234"></a>00234 
<a name="l00235"></a>00235      <span class="comment">// Plane point computation</span>
<a name="l00236"></a>00236      p1 = minPlaneProjection;
<a name="l00237"></a>00237      p1 = p1 + deltaY * line; 
<a name="l00238"></a>00238      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240      <span class="comment">// Scan view column</span>
<a name="l00241"></a>00241      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00242"></a>00242 
<a name="l00243"></a>00243         i = sliceNumber;        <span class="comment">//(column);</span>
<a name="l00244"></a>00244         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>());<span class="comment">//(line);</span>
<a name="l00245"></a>00245         k = (int) (p1.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>());<span class="comment">//(depth);</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247         p1.<a class="code" href="classVPPoint3D.html#a12">vpSetX</a>(sliceNumber);
<a name="l00248"></a>00248         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00249"></a>00249 
<a name="l00250"></a>00250         image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00251"></a>00251 
<a name="l00252"></a>00252         <span class="comment">// Next plane point computation</span>
<a name="l00253"></a>00253         p1 = p1 + deltaX; 
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     } <span class="comment">// for (column)</span>
<a name="l00256"></a>00256 
<a name="l00257"></a>00257  } <span class="comment">// for (line)</span>
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00263"></a>00263 <span class="comment">// Description: Method "vpFrontSliceRender" implement the algorithm </span>
<a name="l00264"></a>00264 <span class="comment">//              to visualize one volume slice from the front.</span>
<a name="l00265"></a>00265 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00266"></a>00266 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00267"></a>00267 <span class="comment">//              to the image);</span>
<a name="l00268"></a>00268 <span class="comment">// Return.....: -</span>
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="classVPSlice.html#a4">00270</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a4">VPSlice::vpFrontSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00271"></a>00271  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00272"></a>00272      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00273"></a>00273      imageXdelta=0, imageYdelta=0, virtualYDimension=0;
<a name="l00274"></a>00274  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, yCorrection=0;
<a name="l00275"></a>00275 
<a name="l00276"></a>00276  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00277"></a>00277  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00278"></a>00278  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280  <span class="comment">// Set pointer to the volume object</span>
<a name="l00281"></a>00281  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00284"></a>00284  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00287"></a>00287  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00288"></a>00288 
<a name="l00289"></a>00289  <span class="comment">// Set projection direction by the vector</span>
<a name="l00290"></a>00290  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00291"></a>00291  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00292"></a>00292 
<a name="l00293"></a>00293  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00294"></a>00294  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00295"></a>00295 
<a name="l00296"></a>00296  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00297"></a>00297  up = camera-&gt;vpGetUp();
<a name="l00298"></a>00298  vectorH = projectionDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(up);
<a name="l00299"></a>00299  vectorV = projectionDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(vectorH);
<a name="l00300"></a>00300 
<a name="l00301"></a>00301  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00302"></a>00302  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00303"></a>00303  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00304"></a>00304 
<a name="l00305"></a>00305  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00306"></a>00306  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00307"></a>00307  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00308"></a>00308 
<a name="l00309"></a>00309  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00310"></a>00310  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00311"></a>00311   <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00312"></a>00312     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00313"></a>00313     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00314"></a>00314     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00315"></a>00315  }
<a name="l00316"></a>00316  <span class="keywordflow">else</span> {
<a name="l00317"></a>00317     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00318"></a>00318     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00319"></a>00319     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00320"></a>00320  }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l00323"></a>00323  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l00324"></a>00324     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l00325"></a>00325  <span class="keywordflow">else</span> 
<a name="l00326"></a>00326     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l00327"></a>00327  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329  <span class="comment">// Window/Viewport ratio</span>
<a name="l00330"></a>00330  ratioX = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00331"></a>00331  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333  <span class="comment">// Line, column and sample step </span>
<a name="l00334"></a>00334  deltaX = vectorH * ratioX;
<a name="l00335"></a>00335  deltaY = vectorV * ratioY;
<a name="l00336"></a>00336  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00339"></a>00339   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00340"></a>00340 
<a name="l00341"></a>00341      <span class="comment">// Plane point computation</span>
<a name="l00342"></a>00342      p1 = minPlaneProjection;
<a name="l00343"></a>00343      p1 = p1 + deltaY * line; 
<a name="l00344"></a>00344      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346      <span class="comment">// Scan view column</span>
<a name="l00347"></a>00347      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         i = (int) (p1.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>());<span class="comment">//(column);</span>
<a name="l00350"></a>00350         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>());<span class="comment">//(line);</span>
<a name="l00351"></a>00351         k = sliceNumber;        <span class="comment">//(depth);</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353         p1.<a class="code" href="classVPPoint3D.html#a14">vpSetZ</a>(sliceNumber);
<a name="l00354"></a>00354         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356         image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="comment">// Next plane point computation</span>
<a name="l00359"></a>00359         p1 = p1 + deltaX; 
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     } <span class="comment">// for (column)</span>
<a name="l00362"></a>00362 
<a name="l00363"></a>00363  } <span class="comment">// for (line)</span>
<a name="l00364"></a>00364 
<a name="l00365"></a>00365 }
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00369"></a>00369 <span class="comment">// Description: Method "vpLineTopSliceRender" implement the algorithm </span>
<a name="l00370"></a>00370 <span class="comment">//              to visualize one volume slice from the top. Lines</span>
<a name="l00371"></a>00371 <span class="comment">//              indicating the position of the other two orthogonal</span>
<a name="l00372"></a>00372 <span class="comment">//              planes are draw in the image.</span>
<a name="l00373"></a>00373 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00374"></a>00374 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00375"></a>00375 <span class="comment">//              to the image);</span>
<a name="l00376"></a>00376 <span class="comment">// Return.....: -</span>
<a name="l00377"></a>00377 
<a name="l00378"></a><a class="code" href="classVPSlice.html#a5">00378</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a5">VPSlice::vpLineTopSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00379"></a>00379  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00380"></a>00380      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00381"></a>00381      imageXdelta=0, imageYdelta=0, whiteLine=0, whiteColumn=0;
<a name="l00382"></a>00382  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0;
<a name="l00383"></a>00383 
<a name="l00384"></a>00384  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00385"></a>00385  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00386"></a>00386  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00387"></a>00387 
<a name="l00388"></a>00388  <span class="comment">// Set pointer to the volume object</span>
<a name="l00389"></a>00389  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00392"></a>00392  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00393"></a>00393 
<a name="l00394"></a>00394  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00395"></a>00395  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00396"></a>00396                 
<a name="l00397"></a>00397  <span class="comment">// Set projection direction by the vector</span>
<a name="l00398"></a>00398  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00399"></a>00399  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00400"></a>00400 
<a name="l00401"></a>00401  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00402"></a>00402  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00403"></a>00403 
<a name="l00404"></a>00404  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00405"></a>00405  up = camera-&gt;vpGetUp();
<a name="l00406"></a>00406  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00407"></a>00407  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00410"></a>00410  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00411"></a>00411  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00412"></a>00412 
<a name="l00413"></a>00413  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00414"></a>00414  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00415"></a>00415  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00416"></a>00416 
<a name="l00417"></a>00417  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00418"></a>00418  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00419"></a>00419  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00420"></a>00420     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00421"></a>00421     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00422"></a>00422     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00423"></a>00423  }
<a name="l00424"></a>00424  <span class="keywordflow">else</span> {
<a name="l00425"></a>00425     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00426"></a>00426     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00427"></a>00427     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00428"></a>00428  }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430  <span class="comment">// Window/Viewport ratio</span>
<a name="l00431"></a>00431  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00432"></a>00432  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434  <span class="comment">// Line, column and sample step </span>
<a name="l00435"></a>00435  deltaX = vectorH * ratioX;
<a name="l00436"></a>00436  deltaY = vectorV * ratioY;
<a name="l00437"></a>00437  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00438"></a>00438 
<a name="l00439"></a>00439  <span class="comment">// Other orthogonal planes visualization values</span>
<a name="l00440"></a>00440  <span class="comment">// (goal: put a line in the right position)</span>
<a name="l00441"></a>00441  <span class="keywordtype">int</span> side = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetSideSlice();
<a name="l00442"></a>00442  <span class="keywordtype">int</span> front = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetFrontSlice();
<a name="l00443"></a>00443  <span class="keywordtype">bool</span> sideFlag = <span class="keyword">true</span>, frontFlag = <span class="keyword">true</span>;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00446"></a>00446   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00447"></a>00447 
<a name="l00448"></a>00448      <span class="comment">// Plane point computation</span>
<a name="l00449"></a>00449      p1 = minPlaneProjection;
<a name="l00450"></a>00450      p1 = p1 + deltaY * line; 
<a name="l00451"></a>00451 
<a name="l00452"></a>00452      <span class="comment">// Scan view column</span>
<a name="l00453"></a>00453      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00454"></a>00454 
<a name="l00455"></a>00455         i = (int) (p1.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>()); <span class="comment">//(column);</span>
<a name="l00456"></a>00456         j = sliceNumber;         <span class="comment">//(line);</span>
<a name="l00457"></a>00457         k = (int) (p1.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>()); <span class="comment">//(depth);</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         p1.<a class="code" href="classVPPoint3D.html#a13">vpSetY</a>(sliceNumber);
<a name="l00460"></a>00460         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00461"></a>00461 
<a name="l00462"></a>00462         <span class="keywordflow">if</span> ( ((k&lt;=front+1)&amp;&amp;(k&gt;=front-1)) &amp;&amp; frontFlag ) {
<a name="l00463"></a>00463             frontFlag = <span class="keyword">false</span>;
<a name="l00464"></a>00464             front = line+imageYdelta;
<a name="l00465"></a>00465         }
<a name="l00466"></a>00466         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ((i&lt;=side+1)&amp;&amp;(i&gt;=side-1)) &amp;&amp; sideFlag ) {
<a name="l00467"></a>00467             sideFlag = <span class="keyword">false</span>;
<a name="l00468"></a>00468             side = column+imageXdelta;
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470         <span class="keywordflow">else</span>
<a name="l00471"></a>00471             image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="comment">// Next plane point computation</span>
<a name="l00474"></a>00474         p1 = p1 + deltaX; 
<a name="l00475"></a>00475 
<a name="l00476"></a>00476     } <span class="comment">// for (column)</span>
<a name="l00477"></a>00477 
<a name="l00478"></a>00478  } <span class="comment">// for (line)</span>
<a name="l00479"></a>00479 
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="comment">// To draw the line of the other orthogonal planes visualization</span>
<a name="l00482"></a>00482   finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00483"></a>00483   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++)
<a name="l00484"></a>00484     image[line][side] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00487"></a>00487   <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++)
<a name="l00488"></a>00488     image[front][column] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 
<a name="l00494"></a>00494 <span class="comment">// Description: Method "vpLineSideSliceRender" implement the algorithm </span>
<a name="l00495"></a>00495 <span class="comment">//              to visualize one volume slice from the side. Lines</span>
<a name="l00496"></a>00496 <span class="comment">//              indicating the position of the other two orthogonal</span>
<a name="l00497"></a>00497 <span class="comment">//              planes are draw in the image.</span>
<a name="l00498"></a>00498 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00499"></a>00499 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00500"></a>00500 <span class="comment">//              to the image);</span>
<a name="l00501"></a>00501 <span class="comment">// Return.....: -</span>
<a name="l00502"></a>00502 
<a name="l00503"></a><a class="code" href="classVPSlice.html#a6">00503</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a6">VPSlice::vpLineSideSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00504"></a>00504  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00505"></a>00505      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00506"></a>00506      imageXdelta=0, imageYdelta=0, virtualYDimension=0;
<a name="l00507"></a>00507  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, yCorrection=0;
<a name="l00508"></a>00508 
<a name="l00509"></a>00509  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00510"></a>00510  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00511"></a>00511  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00512"></a>00512 
<a name="l00513"></a>00513  <span class="comment">// Set pointer to the volume object</span>
<a name="l00514"></a>00514  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00515"></a>00515 
<a name="l00516"></a>00516  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00517"></a>00517  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00520"></a>00520  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00521"></a>00521                 
<a name="l00522"></a>00522  <span class="comment">// Set projection direction by the vector</span>
<a name="l00523"></a>00523  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00524"></a>00524  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00525"></a>00525 
<a name="l00526"></a>00526  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00527"></a>00527  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00528"></a>00528 
<a name="l00529"></a>00529  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00530"></a>00530  up = camera-&gt;vpGetUp();
<a name="l00531"></a>00531  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00532"></a>00532  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l00533"></a>00533 
<a name="l00534"></a>00534  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00535"></a>00535  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00536"></a>00536  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00537"></a>00537 
<a name="l00538"></a>00538  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00539"></a>00539  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00540"></a>00540  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00541"></a>00541 
<a name="l00542"></a>00542  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00543"></a>00543  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00544"></a>00544  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00545"></a>00545     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00546"></a>00546     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00547"></a>00547     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00548"></a>00548  }
<a name="l00549"></a>00549  <span class="keywordflow">else</span> {
<a name="l00550"></a>00550     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00551"></a>00551     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00552"></a>00552     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00553"></a>00553  }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l00556"></a>00556  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l00557"></a>00557     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l00558"></a>00558  <span class="keywordflow">else</span> 
<a name="l00559"></a>00559     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l00560"></a>00560  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562  <span class="comment">// Window/Viewport ratio</span>
<a name="l00563"></a>00563  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00564"></a>00564  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00565"></a>00565 
<a name="l00566"></a>00566  <span class="comment">// Line, column and sample step </span>
<a name="l00567"></a>00567  deltaX = vectorH * ratioX;
<a name="l00568"></a>00568  deltaY = vectorV * ratioY;
<a name="l00569"></a>00569  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00570"></a>00570 
<a name="l00571"></a>00571  <span class="comment">// Other orthogonal planes visualization values</span>
<a name="l00572"></a>00572  <span class="comment">// (goal: put a line in the right position)</span>
<a name="l00573"></a>00573  <span class="keywordtype">int</span> top = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetTopSlice();
<a name="l00574"></a>00574  <span class="keywordtype">int</span> front = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetFrontSlice();
<a name="l00575"></a>00575  <span class="keywordtype">bool</span> topFlag = <span class="keyword">true</span>, frontFlag = <span class="keyword">true</span>;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00578"></a>00578   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00579"></a>00579 
<a name="l00580"></a>00580      <span class="comment">// Plane point computation</span>
<a name="l00581"></a>00581      p1 = minPlaneProjection;
<a name="l00582"></a>00582      p1 = p1 + deltaY * line; 
<a name="l00583"></a>00583      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585      <span class="comment">// Scan view column</span>
<a name="l00586"></a>00586      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00587"></a>00587 
<a name="l00588"></a>00588         i = sliceNumber;        <span class="comment">//(column);</span>
<a name="l00589"></a>00589         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>());<span class="comment">//(line);</span>
<a name="l00590"></a>00590         k = (int) (p1.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>());<span class="comment">//(depth);</span>
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         p1.<a class="code" href="classVPPoint3D.html#a12">vpSetX</a>(sliceNumber);
<a name="l00593"></a>00593         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595         <span class="keywordflow">if</span> ( ((j&lt;=top+1)&amp;&amp;(j&gt;=top-1)) &amp;&amp; topFlag ) {
<a name="l00596"></a>00596             topFlag = <span class="keyword">false</span>;
<a name="l00597"></a>00597             top = line+imageYdelta;
<a name="l00598"></a>00598         }
<a name="l00599"></a>00599         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ((k&lt;=front+1)&amp;&amp;(k&gt;=front-1)) &amp;&amp; frontFlag ) {
<a name="l00600"></a>00600             frontFlag = <span class="keyword">false</span>;
<a name="l00601"></a>00601             front = column+imageXdelta;
<a name="l00602"></a>00602         }
<a name="l00603"></a>00603         <span class="keywordflow">else</span>
<a name="l00604"></a>00604             image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606         <span class="comment">// Next plane point computation</span>
<a name="l00607"></a>00607         p1 = p1 + deltaX; 
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     } <span class="comment">// for (column)</span>
<a name="l00610"></a>00610 
<a name="l00611"></a>00611  } <span class="comment">// for (line)</span>
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00614"></a>00614   <span class="comment">// To draw the line of the other orthogonal planes visualization</span>
<a name="l00615"></a>00615   finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00616"></a>00616   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++)
<a name="l00617"></a>00617     image[line][front] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00620"></a>00620   <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++)
<a name="l00621"></a>00621     image[top][column] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 
<a name="l00627"></a>00627 <span class="comment">// Description: Method "vpLineFrontSliceRender" implement the algorithm </span>
<a name="l00628"></a>00628 <span class="comment">//              to visualize one volume slice from the front. Lines</span>
<a name="l00629"></a>00629 <span class="comment">//              indicating the position of the other two orthogonal</span>
<a name="l00630"></a>00630 <span class="comment">//              planes are draw in the image.</span>
<a name="l00631"></a>00631 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00632"></a>00632 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00633"></a>00633 <span class="comment">//              to the image);</span>
<a name="l00634"></a>00634 <span class="comment">// Return.....: -</span>
<a name="l00635"></a>00635 
<a name="l00636"></a><a class="code" href="classVPSlice.html#a7">00636</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a7">VPSlice::vpLineFrontSliceRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> **image) {
<a name="l00637"></a>00637  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00638"></a>00638      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00639"></a>00639      imageXdelta=0, imageYdelta=0, virtualYDimension=0;
<a name="l00640"></a>00640  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, yCorrection=0;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00643"></a>00643  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, vectorH, vectorV, deltaX, deltaY, up;
<a name="l00644"></a>00644  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection; 
<a name="l00645"></a>00645 
<a name="l00646"></a>00646  <span class="comment">// Set pointer to the volume object</span>
<a name="l00647"></a>00647  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00650"></a>00650  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;
<a name="l00651"></a>00651 
<a name="l00652"></a>00652  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00653"></a>00653  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00654"></a>00654 
<a name="l00655"></a>00655  <span class="comment">// Set projection direction by the vector</span>
<a name="l00656"></a>00656  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00657"></a>00657  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00658"></a>00658 
<a name="l00659"></a>00659  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00660"></a>00660  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00661"></a>00661 
<a name="l00662"></a>00662  <span class="comment">// Set "h" and "v" vectors </span>
<a name="l00663"></a>00663  up = camera-&gt;vpGetUp();
<a name="l00664"></a>00664  vectorH = projectionDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(up);
<a name="l00665"></a>00665  vectorV = projectionDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(vectorH);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00668"></a>00668  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00669"></a>00669  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00670"></a>00670 
<a name="l00671"></a>00671  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00672"></a>00672  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00673"></a>00673  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00674"></a>00674 
<a name="l00675"></a>00675  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00676"></a>00676  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00677"></a>00677   <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00678"></a>00678     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00679"></a>00679     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00680"></a>00680     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00681"></a>00681  }
<a name="l00682"></a>00682  <span class="keywordflow">else</span> {
<a name="l00683"></a>00683     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00684"></a>00684     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00685"></a>00685     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00686"></a>00686  }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l00689"></a>00689  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l00690"></a>00690     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l00691"></a>00691  <span class="keywordflow">else</span> 
<a name="l00692"></a>00692     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l00693"></a>00693  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l00694"></a>00694 
<a name="l00695"></a>00695  <span class="comment">// Window/Viewport ratio</span>
<a name="l00696"></a>00696  ratioX = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00697"></a>00697  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699  <span class="comment">// Line, column and sample step </span>
<a name="l00700"></a>00700  deltaX = vectorH * ratioX;
<a name="l00701"></a>00701  deltaY = vectorV * ratioY;
<a name="l00702"></a>00702  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00703"></a>00703 
<a name="l00704"></a>00704  <span class="comment">// Other orthogonal planes visualization values</span>
<a name="l00705"></a>00705  <span class="comment">// (goal: put a line in the right position)</span>
<a name="l00706"></a>00706  <span class="keywordtype">int</span> top = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetTopSlice();
<a name="l00707"></a>00707  <span class="keywordtype">int</span> side = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetSideSlice();
<a name="l00708"></a>00708  <span class="keywordtype">bool</span> topFlag = <span class="keyword">true</span>, sideFlag = <span class="keyword">true</span>;
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">// Scan view line for the ray tracing </span>
<a name="l00711"></a>00711   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l00712"></a>00712 
<a name="l00713"></a>00713      <span class="comment">// Plane point computation</span>
<a name="l00714"></a>00714      p1 = minPlaneProjection;
<a name="l00715"></a>00715      p1 = p1 + deltaY * line; 
<a name="l00716"></a>00716      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718      <span class="comment">// Scan view column</span>
<a name="l00719"></a>00719      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l00720"></a>00720 
<a name="l00721"></a>00721         i = (int) (p1.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>());<span class="comment">//(column);</span>
<a name="l00722"></a>00722         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>());<span class="comment">//(line);</span>
<a name="l00723"></a>00723         k = sliceNumber;        <span class="comment">//(depth);</span>
<a name="l00724"></a>00724 
<a name="l00725"></a>00725         p1.<a class="code" href="classVPPoint3D.html#a14">vpSetZ</a>(sliceNumber);
<a name="l00726"></a>00726         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="keywordflow">if</span> ( ((j&lt;=top+1)&amp;&amp;(j&gt;=top-1)) &amp;&amp; topFlag ) {
<a name="l00729"></a>00729             topFlag = <span class="keyword">false</span>;
<a name="l00730"></a>00730             top = line+imageYdelta;
<a name="l00731"></a>00731         }
<a name="l00732"></a>00732         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ((i&lt;=side+1)&amp;&amp;(i&gt;=side-1)) &amp;&amp; sideFlag ) {
<a name="l00733"></a>00733             sideFlag = <span class="keyword">false</span>;
<a name="l00734"></a>00734             side = column+imageXdelta;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736         <span class="keywordflow">else</span>
<a name="l00737"></a>00737             image[line+imageYdelta][column+imageXdelta] = (<span class="keywordtype">unsigned</span> int) voxelColor;
<a name="l00738"></a>00738 
<a name="l00739"></a>00739         <span class="comment">// Next plane point computation</span>
<a name="l00740"></a>00740         p1 = p1 + deltaX; 
<a name="l00741"></a>00741 
<a name="l00742"></a>00742     } <span class="comment">// for (column)</span>
<a name="l00743"></a>00743 
<a name="l00744"></a>00744  } <span class="comment">// for (line)</span>
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="comment">// To draw the line of the other orthogonal planes visualization</span>
<a name="l00748"></a>00748   finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00749"></a>00749   <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++)
<a name="l00750"></a>00750     image[line][side] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00753"></a>00753   <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++)
<a name="l00754"></a>00754     image[top][column] = (<span class="keywordtype">unsigned</span> int) 255;
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 
<a name="l00760"></a>00760 <span class="comment">// Description: Method "vpTopInnerStructRender" implement the </span>
<a name="l00761"></a>00761 <span class="comment">//              algorithm to visualize one volume slice from the </span>
<a name="l00762"></a>00762 <span class="comment">//              top. Point indicating the position of the end of </span>
<a name="l00763"></a>00763 <span class="comment">//              S-Band and end of T-Band (used for setting the </span>
<a name="l00764"></a>00764 <span class="comment">//              inner structures parameters visualization) are draw </span>
<a name="l00765"></a>00765 <span class="comment">//              in the image.</span>
<a name="l00766"></a>00766 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l00767"></a>00767 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l00768"></a>00768 <span class="comment">//              to the image with colors);</span>
<a name="l00769"></a>00769 <span class="comment">// Return.....: -</span>
<a name="l00770"></a>00770 
<a name="l00771"></a><a class="code" href="classVPSlice.html#a8">00771</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a8">VPSlice::vpTopInnerStructRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ***image) {
<a name="l00772"></a>00772  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l00773"></a>00773      finalLineValue=0, initialColumnValue=0, finalColumnValue=0,
<a name="l00774"></a>00774      imageXdelta=0, imageYdelta=0, whiteLine=0, whiteColumn=0, cont=0;
<a name="l00775"></a>00775  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, auxFloat=0;
<a name="l00776"></a>00776 
<a name="l00777"></a>00777  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l00778"></a>00778  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, scanDirection, lineScan, vectorH, vectorV, 
<a name="l00779"></a>00779             deltaX, deltaY, up(0,1,0), auxUp;
<a name="l00780"></a>00780  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection, auxTarget, auxPoint, nextPoint, nextLinePoint; 
<a name="l00781"></a>00781  
<a name="l00782"></a>00782  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;  <span class="comment">// Set pointer to the volume object</span>
<a name="l00783"></a>00783 
<a name="l00784"></a>00784  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> volumeCameraLocation = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCameraLocationForInnerStructure();
<a name="l00785"></a>00785  
<a name="l00786"></a>00786  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;  <span class="comment">// Set a pointer to the right camera</span>
<a name="l00787"></a>00787 
<a name="l00788"></a>00788  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l00789"></a>00789  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l00790"></a>00790                 
<a name="l00791"></a>00791  <span class="comment">// Set projection direction by the vector</span>
<a name="l00792"></a>00792  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l00793"></a>00793  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00794"></a>00794 
<a name="l00795"></a>00795  <span class="comment">// Set scan window direction and line scan (for SBand and TBand lines processing)</span>
<a name="l00796"></a>00796  auxTarget = target;
<a name="l00797"></a>00797  scanDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(auxTarget - volumeCameraLocation);
<a name="l00798"></a>00798  scanDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l00799"></a>00799  lineScan = scanDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(up);
<a name="l00800"></a>00800  scanDirection.<a class="code" href="classVPPoint3D.html#o1">y</a> = lineScan.<a class="code" href="classVPPoint3D.html#o1">y</a> = 0;
<a name="l00801"></a>00801 
<a name="l00802"></a>00802  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l00803"></a>00803  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l00804"></a>00804 
<a name="l00805"></a>00805  auxUp = camera-&gt;vpGetUp();
<a name="l00806"></a>00806  vectorH = auxUp.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);  <span class="comment">// Set "h" vector</span>
<a name="l00807"></a>00807  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);  <span class="comment">// Set "v" vector</span>
<a name="l00808"></a>00808 
<a name="l00809"></a>00809  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l00810"></a>00810  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l00811"></a>00811  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l00812"></a>00812 
<a name="l00813"></a>00813  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l00814"></a>00814  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l00815"></a>00815  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l00816"></a>00816 
<a name="l00817"></a>00817  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l00818"></a>00818  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l00819"></a>00819  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l00820"></a>00820     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l00821"></a>00821     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l00822"></a>00822     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l00823"></a>00823  }
<a name="l00824"></a>00824  <span class="keywordflow">else</span> {
<a name="l00825"></a>00825     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l00826"></a>00826     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l00827"></a>00827     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l00828"></a>00828  }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830  <span class="comment">// Window/Viewport ratio</span>
<a name="l00831"></a>00831  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l00832"></a>00832  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834  <span class="comment">// Line, column and sample step </span>
<a name="l00835"></a>00835  deltaX = vectorH * ratioX;
<a name="l00836"></a>00836  deltaY = vectorV * ratioY;
<a name="l00837"></a>00837  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l00838"></a>00838 
<a name="l00839"></a>00839  
<a name="l00841"></a>00841  <span class="comment">// Inner structures visualization parameters</span>
<a name="l00842"></a>00842  <span class="comment">// Goal: exhibition of two points (end of S-Band and T-Band), </span>
<a name="l00843"></a>00843  <span class="comment">//       a line that join them, and a line that identify</span>
<a name="l00844"></a>00844  <span class="comment">//       the ROI (where data will be sampled)</span>
<a name="l00845"></a>00845 
<a name="l00846"></a>00846  <span class="comment">// Necessary variables to set the S-Band and T-Band position in the image</span>
<a name="l00847"></a>00847  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> SBand, TBand, center = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCenterFocalPoint();  
<a name="l00848"></a>00848  <span class="keywordtype">bool</span> findPoint;
<a name="l00849"></a>00849  <span class="keywordtype">int</span> aux=0, arrayDimension, edgeComparison,
<a name="l00850"></a>00850      xDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetXDimension(),
<a name="l00851"></a>00851      zDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l00852"></a>00852  <span class="keywordtype">int</span> edge=0, SBandSteps=0, TBandSteps=0;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854  <span class="comment">// To set arrayDimension (slice diagonal)</span>
<a name="l00855"></a>00855   arrayDimension = (int) ( sqrt( (xDimension*xDimension) + (zDimension*zDimension) ) / 2.0 + 1.0 );
<a name="l00856"></a>00856 
<a name="l00857"></a>00857  <span class="comment">// round value</span>
<a name="l00858"></a>00858  SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l00859"></a>00859  SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l00860"></a>00860  SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingSBand();
<a name="l00861"></a>00861  TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l00862"></a>00862  TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l00863"></a>00863  TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingTBand();
<a name="l00864"></a>00864 
<a name="l00865"></a>00865  <span class="comment">// Process the steps between the edge and SBand and between</span>
<a name="l00866"></a>00866  <span class="comment">// SBand and TBand (using the "middle slice")</span>
<a name="l00867"></a>00867  edge = 0;
<a name="l00868"></a>00868  <span class="keywordflow">while</span> (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>,SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>,edge) &lt;= 40) 
<a name="l00869"></a>00869      edge++;
<a name="l00870"></a>00870  SBandSteps = SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - edge;
<a name="l00871"></a>00871  TBandSteps = TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;        
<a name="l00872"></a>00872 
<a name="l00874"></a>00874  <span class="comment">// First: find the lineSBand and lineTBand points</span>
<a name="l00875"></a>00875  <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>=0;
<a name="l00876"></a>00876  <span class="keywordflow">if</span> (<a class="code" href="classVPSlice.html#p2">lineSBand</a> != <a class="code" href="RasDefine_8h.html#a0">NULL</a>) {
<a name="l00877"></a>00877     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l00878"></a>00878     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l00879"></a>00879  }
<a name="l00880"></a>00880  <a class="code" href="classVPSlice.html#p2">lineSBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l00881"></a>00881  <a class="code" href="classVPSlice.html#p3">lineTBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l00882"></a>00882 
<a name="l00883"></a>00883  <span class="comment">// Find object edge at "SBand column" </span>
<a name="l00884"></a>00884  edge = 0;
<a name="l00885"></a>00885  edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l00886"></a>00886  <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>,sliceNumber,edge) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) )
<a name="l00887"></a>00887     edge++;
<a name="l00888"></a>00888  <span class="keywordflow">if</span> ( edge &lt; edgeComparison )
<a name="l00889"></a>00889     edgeComparison = 1;
<a name="l00890"></a>00890  <span class="keywordflow">else</span>
<a name="l00891"></a>00891     edgeComparison = 0;
<a name="l00892"></a>00892  
<a name="l00893"></a>00893  <span class="comment">// For the case of a very dark slice (top or bottom slice)</span>
<a name="l00894"></a>00894  <span class="keywordflow">if</span> ( edgeComparison )
<a name="l00895"></a>00895  { 
<a name="l00896"></a>00896      <span class="comment">// New SBand and TBand in accordance with scan direction</span>
<a name="l00897"></a>00897      nextPoint = volumeCameraLocation;
<a name="l00898"></a>00898      nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a> = sliceNumber;
<a name="l00899"></a>00899      <a class="code" href="classVPSlice.html#a11">vpFindPointInsideAxialSlice</a>(nextPoint, scanDirection, xDimension, zDimension);
<a name="l00900"></a>00900      <span class="keywordflow">while</span> ( ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40 )
<a name="l00901"></a>00901         nextPoint = nextPoint + scanDirection;
<a name="l00902"></a>00902      
<a name="l00903"></a>00903      SBand = nextPoint;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905      <span class="keywordflow">for</span> (i=0; i&lt;SBandSteps; i++)
<a name="l00906"></a>00906          SBand = SBand + scanDirection;
<a name="l00907"></a>00907         
<a name="l00908"></a>00908      TBand = SBand;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910      <span class="keywordflow">for</span> (i=0; i&lt;TBandSteps; i++)
<a name="l00911"></a>00911          TBand = TBand + scanDirection;
<a name="l00912"></a>00912         
<a name="l00913"></a>00913      <span class="comment">// round value</span>
<a name="l00914"></a>00914      SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l00915"></a>00915      SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l00916"></a>00916      SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l00917"></a>00917      TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l00918"></a>00918      TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l00919"></a>00919      TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l00920"></a>00920 
<a name="l00921"></a>00921      <span class="comment">// lineScan to find the positions at scanDirection</span>
<a name="l00922"></a>00922      <span class="comment">// (from the center to left, and from the center to right)</span>
<a name="l00923"></a>00923      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>;
<a name="l00924"></a>00924      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;
<a name="l00925"></a>00925      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = TBand.<a class="code" href="classVPPoint3D.html#o0">x</a>;          
<a name="l00926"></a>00926      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = TBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;
<a name="l00927"></a>00927      findPoint = <span class="keyword">true</span>;
<a name="l00928"></a>00928      <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l00929"></a>00929 
<a name="l00930"></a>00930      nextLinePoint = volumeCameraLocation;
<a name="l00931"></a>00931      nextLinePoint.<a class="code" href="classVPPoint3D.html#o1">y</a> = sliceNumber;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933      <span class="comment">// First, process "right" points</span>
<a name="l00934"></a>00934      <span class="keywordflow">while</span> (findPoint) {
<a name="l00935"></a>00935         nextLinePoint = nextLinePoint + lineScan + lineScan; <span class="comment">// next point after SBand in line scan</span>
<a name="l00936"></a>00936         nextPoint = nextLinePoint;
<a name="l00937"></a>00937         <a class="code" href="classVPSlice.html#a11">vpFindPointInsideAxialSlice</a>(nextPoint, scanDirection, xDimension, zDimension);
<a name="l00938"></a>00938         edge = 0;
<a name="l00939"></a>00939         edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l00940"></a>00940         <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) ) 
<a name="l00941"></a>00941         {
<a name="l00942"></a>00942             nextPoint = nextPoint + scanDirection;
<a name="l00943"></a>00943             edge++;
<a name="l00944"></a>00944             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l00945"></a>00945                 <span class="keywordflow">break</span>;
<a name="l00946"></a>00946         }
<a name="l00947"></a>00947         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension))
<a name="l00948"></a>00948                 edgeComparison = 0;
<a name="l00949"></a>00949         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l00950"></a>00950                     edgeComparison = 1;
<a name="l00951"></a>00951                 <span class="keywordflow">else</span> 
<a name="l00952"></a>00952                     edgeComparison = 0;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// if the column "hit the volume"</span>
<a name="l00955"></a>00955             <span class="comment">// nextPoint is 3D, but y is the selected slice </span>
<a name="l00956"></a>00956             <span class="comment">// lineSBand is 2D; since y is always the same, x=nextPoint.x and y=nextPoint.z (the point in the "slice plane")</span>
<a name="l00957"></a>00957             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a> + (SBandSteps * scanDirection.x);
<a name="l00958"></a>00958             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a> + (SBandSteps * scanDirection.z); 
<a name="l00959"></a>00959             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.x);
<a name="l00960"></a>00960             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.z); 
<a name="l00961"></a>00961             
<a name="l00962"></a>00962             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l00963"></a>00963         }
<a name="l00964"></a>00964         <span class="keywordflow">else</span> { <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l00965"></a>00965             findPoint = <span class="keyword">false</span>;  
<a name="l00966"></a>00966             aux = <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>;
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968      } <span class="comment">// while</span>
<a name="l00969"></a>00969      findPoint = <span class="keyword">true</span>;
<a name="l00970"></a>00970      nextLinePoint = volumeCameraLocation;
<a name="l00971"></a>00971      nextLinePoint.<a class="code" href="classVPPoint3D.html#o1">y</a> = sliceNumber;
<a name="l00972"></a>00972      nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l00973"></a>00973      nextPoint = nextLinePoint;
<a name="l00974"></a>00974      <a class="code" href="classVPSlice.html#a11">vpFindPointInsideAxialSlice</a>(nextPoint, scanDirection, xDimension, zDimension);
<a name="l00975"></a>00975 
<a name="l00976"></a>00976      <span class="comment">// Second, process "left" points</span>
<a name="l00977"></a>00977      <span class="keywordflow">while</span> (findPoint) {
<a name="l00978"></a>00978         edge = 0;
<a name="l00979"></a>00979         edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) ) 
<a name="l00982"></a>00982         {
<a name="l00983"></a>00983             nextPoint = nextPoint + scanDirection;
<a name="l00984"></a>00984             edge++;
<a name="l00985"></a>00985             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l00986"></a>00986                 <span class="keywordflow">break</span>;
<a name="l00987"></a>00987         }
<a name="l00988"></a>00988         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension))
<a name="l00989"></a>00989                 edgeComparison = 0;
<a name="l00990"></a>00990         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l00991"></a>00991                     edgeComparison = 1;
<a name="l00992"></a>00992                 <span class="keywordflow">else</span> 
<a name="l00993"></a>00993                     edgeComparison = 0;
<a name="l00994"></a>00994 
<a name="l00995"></a>00995         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// the column "hit the volume"</span>
<a name="l00996"></a>00996 
<a name="l00997"></a>00997             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a> + (SBandSteps * scanDirection.x);
<a name="l00998"></a>00998             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a> + (SBandSteps * scanDirection.z); 
<a name="l00999"></a>00999             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.x);
<a name="l01000"></a>01000             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.z); 
<a name="l01001"></a>01001             nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l01002"></a>01002             nextPoint = nextLinePoint;
<a name="l01003"></a>01003             <a class="code" href="classVPSlice.html#a11">vpFindPointInsideAxialSlice</a>(nextPoint, scanDirection, xDimension, zDimension);
<a name="l01004"></a>01004             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01005"></a>01005         }
<a name="l01006"></a>01006         <span class="keywordflow">else</span> <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l01007"></a>01007             findPoint = <span class="keyword">false</span>;  
<a name="l01008"></a>01008      }
<a name="l01009"></a>01009  }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011  <a class="code" href="classVPSlice.html#a14">vpOrder</a>(arrayDimension, <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>, aux);
<a name="l01012"></a>01012 
<a name="l01014"></a>01014  <span class="comment">// Scan view line for the ray casting </span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016  <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018      <span class="comment">// Plane point computation</span>
<a name="l01019"></a>01019      p1 = minPlaneProjection;
<a name="l01020"></a>01020      p1 = p1 + deltaY * line; 
<a name="l01021"></a>01021 
<a name="l01022"></a>01022      <span class="comment">// Scan view column</span>
<a name="l01023"></a>01023      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         i = (int) (p1.<a class="code" href="classVPPoint3D.html#o0">x</a>); <span class="comment">//(column);</span>
<a name="l01026"></a>01026         j = sliceNumber;  <span class="comment">//(line);</span>
<a name="l01027"></a>01027         k = (int) (p1.<a class="code" href="classVPPoint3D.html#o2">z</a>); <span class="comment">//(depth);</span>
<a name="l01028"></a>01028 
<a name="l01029"></a>01029         p1.<a class="code" href="classVPPoint3D.html#a13">vpSetY</a>(sliceNumber);
<a name="l01030"></a>01030         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l01031"></a>01031 
<a name="l01032"></a>01032         <span class="comment">//i = (int) (p1.x+0.5);</span>
<a name="l01033"></a>01033 
<a name="l01034"></a>01034         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a11">red</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01035"></a>01035         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a12">green</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01036"></a>01036         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a13">blue</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01037"></a>01037 
<a name="l01038"></a>01038         <span class="comment">// Next plane point computation</span>
<a name="l01039"></a>01039         p1 = p1 + deltaX; 
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     } <span class="comment">// for (column)</span>
<a name="l01042"></a>01042 
<a name="l01043"></a>01043  } <span class="comment">// for (line)</span>
<a name="l01044"></a>01044 
<a name="l01045"></a>01045  <span class="comment">// Mapping endOfSBand and endOfTBand from the window to the viewport</span>
<a name="l01046"></a>01046  auxFloat = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01047"></a>01047  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a>-zDimension)) / zDimension + finalLineValue;
<a name="l01048"></a>01048  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*auxFloat) / xDimension );
<a name="l01049"></a>01049  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01050"></a>01050  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01051"></a>01051  auxFloat = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01052"></a>01052  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a>-zDimension)) / zDimension + finalLineValue;
<a name="l01053"></a>01053  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*auxFloat) / xDimension );
<a name="l01054"></a>01054  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01055"></a>01055  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01056"></a>01056 
<a name="l01057"></a>01057  <span class="comment">// Mapping lineTBand and lineSBand points from the window to the viewport</span>
<a name="l01058"></a>01058  <span class="keywordflow">for</span> (cont=0; cont&lt;<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>; cont++) {
<a name="l01059"></a>01059     auxFloat = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01060"></a>01060     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a>-zDimension)) / zDimension + finalLineValue;
<a name="l01061"></a>01061     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*auxFloat) / xDimension );
<a name="l01062"></a>01062     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01063"></a>01063     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065     auxFloat = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01066"></a>01066     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a>-zDimension)) / zDimension + finalLineValue;
<a name="l01067"></a>01067     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*auxFloat) / xDimension );
<a name="l01068"></a>01068     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01069"></a>01069     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01070"></a>01070  }
<a name="l01071"></a>01071 
<a name="l01072"></a>01072 }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074 
<a name="l01076"></a>01076 <span class="comment">// Description: Method "vpSideInnerStructRender" implement the </span>
<a name="l01077"></a>01077 <span class="comment">//              algorithm to visualize one volume slice from the </span>
<a name="l01078"></a>01078 <span class="comment">//              side. Point indicating the position of the end of </span>
<a name="l01079"></a>01079 <span class="comment">//              S-Band and end of T-Band (used for setting the </span>
<a name="l01080"></a>01080 <span class="comment">//              inner structures parameters visualization) are draw </span>
<a name="l01081"></a>01081 <span class="comment">//              in the image.</span>
<a name="l01082"></a>01082 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l01083"></a>01083 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l01084"></a>01084 <span class="comment">//              to the image with colors);</span>
<a name="l01085"></a>01085 <span class="comment">// Return.....: -</span>
<a name="l01086"></a>01086 
<a name="l01087"></a><a class="code" href="classVPSlice.html#a9">01087</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a9">VPSlice::vpSideInnerStructRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ***image) {
<a name="l01088"></a>01088  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l01089"></a>01089      finalLineValue=0, initialColumnValue=0, finalColumnValue=0, virtualYDimension=0,
<a name="l01090"></a>01090      imageXdelta=0, imageYdelta=0, whiteLine=0, whiteColumn=0, cont=0;
<a name="l01091"></a>01091  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, auxFloat=0, yCorrection=0;
<a name="l01092"></a>01092 
<a name="l01093"></a>01093  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l01094"></a>01094  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, scanDirection, lineScan, vectorH, vectorV, 
<a name="l01095"></a>01095             deltaX, deltaY, xAxis(1,0,0), up;
<a name="l01096"></a>01096  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection, auxTarget, auxPoint, nextPoint, nextLinePoint; 
<a name="l01097"></a>01097  
<a name="l01098"></a>01098  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;  <span class="comment">// Set pointer to the volume object</span>
<a name="l01099"></a>01099 
<a name="l01100"></a>01100  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> volumeCameraLocation = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCameraLocationForInnerStructure();
<a name="l01101"></a>01101  
<a name="l01102"></a>01102  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;  <span class="comment">// Set a pointer to the right camera</span>
<a name="l01103"></a>01103 
<a name="l01104"></a>01104  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l01105"></a>01105  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l01106"></a>01106                 
<a name="l01107"></a>01107  <span class="comment">// Set projection direction by the vector</span>
<a name="l01108"></a>01108  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l01109"></a>01109  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l01110"></a>01110 
<a name="l01111"></a>01111  <span class="comment">// Set scan window direction and line scan (for SBand and TBand lines processing)</span>
<a name="l01112"></a>01112  auxTarget = target;
<a name="l01113"></a>01113  scanDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(auxTarget - volumeCameraLocation);
<a name="l01114"></a>01114  scanDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l01115"></a>01115  lineScan = scanDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(xAxis);
<a name="l01116"></a>01116  scanDirection.<a class="code" href="classVPPoint3D.html#o0">x</a> = lineScan.<a class="code" href="classVPPoint3D.html#o0">x</a> = 0;
<a name="l01117"></a>01117 
<a name="l01118"></a>01118  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l01119"></a>01119  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l01120"></a>01120 
<a name="l01121"></a>01121  up = camera-&gt;vpGetUp();
<a name="l01122"></a>01122  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l01123"></a>01123  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l01124"></a>01124 
<a name="l01125"></a>01125  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l01126"></a>01126  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l01127"></a>01127  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l01128"></a>01128 
<a name="l01129"></a>01129  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l01130"></a>01130  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l01131"></a>01131  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l01132"></a>01132 
<a name="l01133"></a>01133  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l01134"></a>01134  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l01135"></a>01135  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l01136"></a>01136     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l01137"></a>01137     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l01138"></a>01138     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l01139"></a>01139  }
<a name="l01140"></a>01140  <span class="keywordflow">else</span> {
<a name="l01141"></a>01141     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l01142"></a>01142     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l01143"></a>01143     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l01144"></a>01144  }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l01147"></a>01147  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l01148"></a>01148     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l01149"></a>01149  <span class="keywordflow">else</span> 
<a name="l01150"></a>01150     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l01151"></a>01151  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l01152"></a>01152 
<a name="l01153"></a>01153  <span class="comment">// Window/Viewport ratio</span>
<a name="l01154"></a>01154  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l01155"></a>01155  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l01156"></a>01156 
<a name="l01157"></a>01157  <span class="comment">// Line, column and sample step </span>
<a name="l01158"></a>01158  deltaX = vectorH * ratioX;
<a name="l01159"></a>01159  deltaY = vectorV * ratioY;
<a name="l01160"></a>01160  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l01161"></a>01161  
<a name="l01163"></a>01163  <span class="comment">// Inner structures visualization parameters</span>
<a name="l01164"></a>01164  <span class="comment">// Goal: exhibition of two points (end of S-Band and T-Band), </span>
<a name="l01165"></a>01165  <span class="comment">//       a line that join them, and a line that identify</span>
<a name="l01166"></a>01166  <span class="comment">//       the ROI (where data will be sampled)</span>
<a name="l01167"></a>01167 
<a name="l01168"></a>01168  <span class="comment">// Necessary variables to set the S-Band and T-Band position in the image</span>
<a name="l01169"></a>01169  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> SBand, TBand, center = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCenterFocalPoint();  
<a name="l01170"></a>01170  <span class="keywordtype">bool</span> findPoint;
<a name="l01171"></a>01171  <span class="keywordtype">int</span> aux=0, arrayDimension, edgeComparison, matrixValue,
<a name="l01172"></a>01172      yDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetYDimension(),
<a name="l01173"></a>01173      zDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l01174"></a>01174  <span class="keywordtype">int</span> edge=0, SBandSteps=0, TBandSteps=0;
<a name="l01175"></a>01175 
<a name="l01176"></a>01176  <span class="comment">// To set arrayDimension (slice diagonal)</span>
<a name="l01177"></a>01177   arrayDimension = (int) ( sqrt( (yDimension*yDimension) + (zDimension*zDimension) ) / 2.0 + 1.0 );
<a name="l01178"></a>01178 
<a name="l01179"></a>01179    <span class="comment">// round value</span>
<a name="l01180"></a>01180  SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01181"></a>01181  SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01182"></a>01182  SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingSBand();
<a name="l01183"></a>01183  TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01184"></a>01184  TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01185"></a>01185  TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingTBand();
<a name="l01186"></a>01186 
<a name="l01187"></a>01187  <span class="comment">// Process the steps between the edge and SBand and between</span>
<a name="l01188"></a>01188  <span class="comment">// SBand and TBand (using the "middle slice")</span>
<a name="l01189"></a>01189  edge = 0;
<a name="l01190"></a>01190  <span class="keywordflow">while</span> (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>,SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>,edge) &lt;= 40) 
<a name="l01191"></a>01191      edge++;
<a name="l01192"></a>01192  SBandSteps = SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - edge;
<a name="l01193"></a>01193  TBandSteps = TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;
<a name="l01194"></a>01194 
<a name="l01196"></a>01196  <span class="comment">// First: find the lineSBand and lineTBand points</span>
<a name="l01197"></a>01197  <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>=0;
<a name="l01198"></a>01198  <span class="keywordflow">if</span> (<a class="code" href="classVPSlice.html#p2">lineSBand</a> != <a class="code" href="RasDefine_8h.html#a0">NULL</a>) {
<a name="l01199"></a>01199     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l01200"></a>01200     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l01201"></a>01201  }
<a name="l01202"></a>01202  <a class="code" href="classVPSlice.html#p2">lineSBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l01203"></a>01203  <a class="code" href="classVPSlice.html#p3">lineTBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l01204"></a>01204 
<a name="l01205"></a>01205  <span class="comment">// Find object edge at "SBand column"</span>
<a name="l01206"></a>01206  edge = 0;
<a name="l01207"></a>01207  edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l01208"></a>01208  <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(sliceNumber,SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>,edge) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) )
<a name="l01209"></a>01209     edge++;
<a name="l01210"></a>01210  <span class="keywordflow">if</span> ( edge &lt; edgeComparison )
<a name="l01211"></a>01211     edgeComparison = 1;
<a name="l01212"></a>01212  <span class="keywordflow">else</span>
<a name="l01213"></a>01213     edgeComparison = 0;
<a name="l01214"></a>01214  
<a name="l01215"></a>01215  <span class="comment">// For the case of a very dark slice (top or bottom slice)</span>
<a name="l01216"></a>01216  <span class="keywordflow">if</span> ( edgeComparison )
<a name="l01217"></a>01217  { 
<a name="l01218"></a>01218      <span class="comment">// New SBand and TBand in accordance with scan direction</span>
<a name="l01219"></a>01219      nextPoint = volumeCameraLocation;
<a name="l01220"></a>01220      nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a> = sliceNumber;
<a name="l01221"></a>01221      <a class="code" href="classVPSlice.html#a12">vpFindPntInsideSagittalSlice</a>(nextPoint, scanDirection, virtualYDimension, zDimension); <span class="comment">// @@ YDimension</span>
<a name="l01222"></a>01222      <span class="keywordflow">while</span> ( ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40 ) <span class="comment">// @@ Tirar *yCorrection</span>
<a name="l01223"></a>01223         nextPoint = nextPoint + scanDirection;
<a name="l01224"></a>01224      
<a name="l01225"></a>01225      SBand = nextPoint;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227      <span class="keywordflow">for</span> (i=0; i&lt;SBandSteps; i++)
<a name="l01228"></a>01228          SBand = SBand + scanDirection;
<a name="l01229"></a>01229         
<a name="l01230"></a>01230      TBand = SBand;
<a name="l01231"></a>01231 
<a name="l01232"></a>01232      <span class="keywordflow">for</span> (i=0; i&lt;TBandSteps; i++)
<a name="l01233"></a>01233          TBand = TBand + scanDirection;
<a name="l01234"></a>01234         
<a name="l01235"></a>01235      <span class="comment">// round value</span>
<a name="l01236"></a>01236      SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01237"></a>01237      SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01238"></a>01238      SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l01239"></a>01239      TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01240"></a>01240      TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01241"></a>01241      TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243      <span class="comment">// lineScan to find the positions at scanDirection</span>
<a name="l01244"></a>01244      <span class="comment">// (from the center to left, and from the center to right)</span>
<a name="l01245"></a>01245      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;
<a name="l01246"></a>01246      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection; <span class="comment">// @@ tirar *yCorrection</span>
<a name="l01247"></a>01247      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = TBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;          
<a name="l01248"></a>01248      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = TBand.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection; <span class="comment">// @@ tirar *yCorrection</span>
<a name="l01249"></a>01249      findPoint = <span class="keyword">true</span>;
<a name="l01250"></a>01250      <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01251"></a>01251 
<a name="l01252"></a>01252      nextLinePoint = volumeCameraLocation;
<a name="l01253"></a>01253      nextLinePoint.<a class="code" href="classVPPoint3D.html#o0">x</a> = sliceNumber;
<a name="l01254"></a>01254 
<a name="l01255"></a>01255      <span class="comment">// First, process "right" points</span>
<a name="l01256"></a>01256      <span class="keywordflow">while</span> (findPoint) {
<a name="l01257"></a>01257         nextLinePoint = nextLinePoint + lineScan + lineScan; <span class="comment">// next point after SBand in line scan</span>
<a name="l01258"></a>01258         nextPoint = nextLinePoint;
<a name="l01259"></a>01259         edge = 0;
<a name="l01260"></a>01260         edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l01261"></a>01261         <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l01262"></a>01262         {
<a name="l01263"></a>01263             nextPoint = nextPoint + scanDirection;
<a name="l01264"></a>01264             edge++; <span class="comment">// to verify if the point is out of the volume (edge must be &lt;= edgeComparison)</span>
<a name="l01265"></a>01265             <span class="keywordflow">if</span> (edge &gt; edgeComparison)
<a name="l01266"></a>01266                 <span class="keywordflow">break</span>;
<a name="l01267"></a>01267         }
<a name="l01268"></a>01268         <span class="keywordflow">if</span> (edge &lt;= edgeComparison)
<a name="l01269"></a>01269         {
<a name="l01270"></a>01270             edge = 0;
<a name="l01271"></a>01271             matrixValue = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>);
<a name="l01272"></a>01272         }
<a name="l01273"></a>01273         <span class="keywordflow">else</span>
<a name="l01274"></a>01274             matrixValue = 0;
<a name="l01275"></a>01275         <span class="keywordflow">while</span> ( (matrixValue &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) )  <span class="comment">// @@ Tirar *yCorrection</span>
<a name="l01276"></a>01276         {
<a name="l01277"></a>01277             nextPoint = nextPoint + scanDirection;
<a name="l01278"></a>01278             edge++;
<a name="l01279"></a>01279             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) ) <span class="comment">// @@ yDimension </span>
<a name="l01280"></a>01280                 <span class="keywordflow">break</span>;
<a name="l01281"></a>01281             matrixValue = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>);
<a name="l01282"></a>01282         }
<a name="l01283"></a>01283         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension)) <span class="comment">// @@ yDimension </span>
<a name="l01284"></a>01284                 edgeComparison = 0;
<a name="l01285"></a>01285         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l01286"></a>01286                     edgeComparison = 1;
<a name="l01287"></a>01287                 <span class="keywordflow">else</span> 
<a name="l01288"></a>01288                     edgeComparison = 0;
<a name="l01289"></a>01289 
<a name="l01290"></a>01290         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// if the column "hit the volume"</span>
<a name="l01291"></a>01291             <span class="comment">// nextPoint is 3D, but x is the selected slice </span>
<a name="l01292"></a>01292             <span class="comment">// lineSBand is 2D; since x is always the same, x=nextPoint.z and y=nextPoint.y (the point in the "slice plane")</span>
<a name="l01293"></a>01293             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a> + (SBandSteps * scanDirection.z);
<a name="l01294"></a>01294             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection + (SBandSteps * scanDirection.y); <span class="comment">// @@ Tirar *yCorrection</span>
<a name="l01295"></a>01295             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.z);
<a name="l01296"></a>01296             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.y); 
<a name="l01297"></a>01297             
<a name="l01298"></a>01298             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01299"></a>01299         }
<a name="l01300"></a>01300         <span class="keywordflow">else</span> { <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l01301"></a>01301             findPoint = <span class="keyword">false</span>;  
<a name="l01302"></a>01302             aux = <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>;
<a name="l01303"></a>01303         }
<a name="l01304"></a>01304      } <span class="comment">// while</span>
<a name="l01305"></a>01305      findPoint = <span class="keyword">true</span>;
<a name="l01306"></a>01306      nextLinePoint = volumeCameraLocation;
<a name="l01307"></a>01307      nextLinePoint.<a class="code" href="classVPPoint3D.html#o0">x</a> = sliceNumber;
<a name="l01308"></a>01308      nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l01309"></a>01309      nextPoint = nextLinePoint;
<a name="l01310"></a>01310      <a class="code" href="classVPSlice.html#a12">vpFindPntInsideSagittalSlice</a>(nextPoint, scanDirection, virtualYDimension, zDimension); 
<a name="l01311"></a>01311 
<a name="l01312"></a>01312      <span class="comment">// Second, process "left" points</span>
<a name="l01313"></a>01313      <span class="keywordflow">while</span> (findPoint) {
<a name="l01314"></a>01314         edge = 0;
<a name="l01315"></a>01315         edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l01316"></a>01316 
<a name="l01317"></a>01317         <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) ) 
<a name="l01318"></a>01318         {
<a name="l01319"></a>01319             nextPoint = nextPoint + scanDirection;
<a name="l01320"></a>01320             edge++;
<a name="l01321"></a>01321             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l01322"></a>01322                 <span class="keywordflow">break</span>;
<a name="l01323"></a>01323         }
<a name="l01324"></a>01324         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension))
<a name="l01325"></a>01325                 edgeComparison = 0;
<a name="l01326"></a>01326         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l01327"></a>01327                     edgeComparison = 1;
<a name="l01328"></a>01328                 <span class="keywordflow">else</span> 
<a name="l01329"></a>01329                     edgeComparison = 0;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// the column "hit the volume"</span>
<a name="l01332"></a>01332             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a> + (SBandSteps * scanDirection.z);
<a name="l01333"></a>01333             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection + (SBandSteps * scanDirection.y); 
<a name="l01334"></a>01334             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.z);
<a name="l01335"></a>01335             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.y); 
<a name="l01336"></a>01336             nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l01337"></a>01337             nextPoint = nextLinePoint;
<a name="l01338"></a>01338             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340             <span class="comment">// Guarantee that the next point is inside the volume...</span>
<a name="l01341"></a>01341             edge = 0;
<a name="l01342"></a>01342             edgeComparison = 0.8 * zDimension; <span class="comment">// 80%</span>
<a name="l01343"></a>01343             <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=virtualYDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )   {
<a name="l01344"></a>01344                 nextPoint = nextPoint + scanDirection;
<a name="l01345"></a>01345                 edge++; 
<a name="l01346"></a>01346                 <span class="keywordflow">if</span> (edge &gt; edgeComparison)<span class="comment">// to verify if the point is out of the volume (edge must be &lt;= edgeComparison)</span>
<a name="l01347"></a>01347                     <span class="keywordflow">break</span>;
<a name="l01348"></a>01348             }
<a name="l01349"></a>01349             <span class="keywordflow">if</span> (edge &gt; edgeComparison)
<a name="l01350"></a>01350                 findPoint = <span class="keyword">false</span>;
<a name="l01351"></a>01351         }
<a name="l01352"></a>01352         <span class="keywordflow">else</span> <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l01353"></a>01353             findPoint = <span class="keyword">false</span>;  
<a name="l01354"></a>01354      }
<a name="l01355"></a>01355  }
<a name="l01356"></a>01356 
<a name="l01357"></a>01357  <a class="code" href="classVPSlice.html#a14">vpOrder</a>(arrayDimension, <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>, aux);
<a name="l01358"></a>01358 
<a name="l01360"></a>01360  <span class="comment">// Scan view line for the ray casting </span>
<a name="l01361"></a>01361 
<a name="l01362"></a>01362  <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l01363"></a>01363 
<a name="l01364"></a>01364      <span class="comment">// Plane point computation</span>
<a name="l01365"></a>01365      p1 = minPlaneProjection;
<a name="l01366"></a>01366      p1 = p1 + deltaY * line; 
<a name="l01367"></a>01367      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369      <span class="comment">// Scan view column</span>
<a name="l01370"></a>01370      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         i = sliceNumber;        <span class="comment">//(column);</span>
<a name="l01373"></a>01373         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>());<span class="comment">//(line);</span>
<a name="l01374"></a>01374         k = (int) (p1.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>());<span class="comment">//(depth);</span>
<a name="l01375"></a>01375 
<a name="l01376"></a>01376         p1.<a class="code" href="classVPPoint3D.html#a12">vpSetX</a>(sliceNumber);
<a name="l01377"></a>01377         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l01378"></a>01378 
<a name="l01379"></a>01379         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a11">red</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01380"></a>01380         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a12">green</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01381"></a>01381         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a13">blue</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01382"></a>01382 
<a name="l01383"></a>01383         <span class="comment">// Next plane point computation</span>
<a name="l01384"></a>01384         p1 = p1 + deltaX; 
<a name="l01385"></a>01385 
<a name="l01386"></a>01386     } <span class="comment">// for (column)</span>
<a name="l01387"></a>01387 
<a name="l01388"></a>01388  } <span class="comment">// for (line)</span>
<a name="l01389"></a>01389 
<a name="l01390"></a>01390  <span class="comment">// Mapping endOfSBand and endOfTBand from the window to the viewport</span>
<a name="l01391"></a>01391  auxFloat = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01392"></a>01392  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = ( (-finalLineValue)*<a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> ) / yDimension + finalLineValue;
<a name="l01393"></a>01393  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-zDimension)) / -zDimension );
<a name="l01394"></a>01394  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01395"></a>01395  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01396"></a>01396  auxFloat = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01397"></a>01397  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = ( (-finalLineValue)*<a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> ) / yDimension + finalLineValue;
<a name="l01398"></a>01398  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-zDimension)) / -zDimension );
<a name="l01399"></a>01399  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01400"></a>01400  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01401"></a>01401 
<a name="l01402"></a>01402 
<a name="l01403"></a>01403 
<a name="l01404"></a>01404  <span class="comment">// Mapping lineTBand and lineSBand points from the window to the viewport</span>
<a name="l01405"></a>01405  <span class="keywordflow">for</span> (cont=0; cont&lt;<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>; cont++) {
<a name="l01406"></a>01406     auxFloat = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01407"></a>01407     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = ( (-finalLineValue)*<a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> ) / yDimension + finalLineValue;
<a name="l01408"></a>01408     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-zDimension)) / -zDimension );
<a name="l01409"></a>01409     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01410"></a>01410     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     auxFloat = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01413"></a>01413     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = ( (-finalLineValue)*<a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> ) / yDimension + finalLineValue;
<a name="l01414"></a>01414     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-zDimension)) / -zDimension );
<a name="l01415"></a>01415     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01416"></a>01416     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01417"></a>01417  }
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 
<a name="l01423"></a>01423 <span class="comment">// Description: Method "vpFrontInnerStructRender" implement the </span>
<a name="l01424"></a>01424 <span class="comment">//              algorithm to visualize one volume slice from the </span>
<a name="l01425"></a>01425 <span class="comment">//              front. Point indicating the position of the end of </span>
<a name="l01426"></a>01426 <span class="comment">//              S-Band and end of T-Band (used for setting the </span>
<a name="l01427"></a>01427 <span class="comment">//              inner structures parameters visualization) are draw </span>
<a name="l01428"></a>01428 <span class="comment">//              in the image.</span>
<a name="l01429"></a>01429 <span class="comment">// Parameters.: VPCamera *c (active camera), VPGraphicObj *v, </span>
<a name="l01430"></a>01430 <span class="comment">//              int sliceNumber, unsigned int image[][256] (pointer </span>
<a name="l01431"></a>01431 <span class="comment">//              to the image with colors);</span>
<a name="l01432"></a>01432 <span class="comment">// Return.....: -</span>
<a name="l01433"></a>01433 
<a name="l01434"></a><a class="code" href="classVPSlice.html#a10">01434</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a10">VPSlice::vpFrontInnerStructRender</a>(<a class="code" href="classVPCamera.html">VPCamera</a> *c, <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *v, <span class="keywordtype">int</span> sliceNumber, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ***image) {
<a name="l01435"></a>01435  <span class="keywordtype">int</span> line=0, column=0, i=0, j=0, k=0, initialLineValue=0, 
<a name="l01436"></a>01436      finalLineValue=0, initialColumnValue=0, finalColumnValue=0, virtualYDimension=0,
<a name="l01437"></a>01437      imageXdelta=0, imageYdelta=0, whiteLine=0, whiteColumn=0, cont=0;
<a name="l01438"></a>01438  <span class="keywordtype">float</span> voxelColor=0, ratioX=0, ratioY=0, deltaZ=0, auxRatio=0, auxFloat=0, yCorrection=0;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> winTopRightValue;
<a name="l01441"></a>01441  <a class="code" href="classVPVector3D.html">VPVector3D</a> projectionDirection, scanDirection, lineScan, vectorH, vectorV, 
<a name="l01442"></a>01442             deltaX, deltaY, zAxis(0,0,1), up;
<a name="l01443"></a>01443  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p1, minPlaneProjection, auxTarget, auxPoint, nextPoint, nextLinePoint; 
<a name="l01444"></a>01444  
<a name="l01445"></a>01445  <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume = v;  <span class="comment">// Set pointer to the volume object</span>
<a name="l01446"></a>01446 
<a name="l01447"></a>01447  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> volumeCameraLocation = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCameraLocationForInnerStructure();
<a name="l01448"></a>01448  
<a name="l01449"></a>01449  <a class="code" href="classVPCamera.html">VPCamera</a> *camera = c;  <span class="comment">// Set a pointer to the right camera</span>
<a name="l01450"></a>01450 
<a name="l01451"></a>01451  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> location = camera-&gt;vpGetLocation();
<a name="l01452"></a>01452  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> target = camera-&gt;vpGetTarget();
<a name="l01453"></a>01453                 
<a name="l01454"></a>01454  <span class="comment">// Set projection direction by the vector</span>
<a name="l01455"></a>01455  projectionDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(target - location);
<a name="l01456"></a>01456  projectionDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l01457"></a>01457 
<a name="l01458"></a>01458  <span class="comment">// Set scan window direction and line scan (for SBand and TBand lines processing)</span>
<a name="l01459"></a>01459  auxTarget = target;
<a name="l01460"></a>01460  scanDirection.<a class="code" href="classVPVector3D.html#a22">vpSetVector3D</a>(auxTarget - volumeCameraLocation);
<a name="l01461"></a>01461  scanDirection.<a class="code" href="classVPVector3D.html#a21">vpNormalize</a>();
<a name="l01462"></a>01462  lineScan = scanDirection.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(zAxis);
<a name="l01463"></a>01463  scanDirection.<a class="code" href="classVPPoint3D.html#o2">z</a> = lineScan.<a class="code" href="classVPPoint3D.html#o2">z</a> = 0;
<a name="l01464"></a>01464 
<a name="l01465"></a>01465  <span class="comment">// winTopRightValue has the projection plane size (x,y)</span>
<a name="l01466"></a>01466  winTopRightValue = camera-&gt;vpGetWinTopRight();
<a name="l01467"></a>01467 
<a name="l01468"></a>01468  up = camera-&gt;vpGetUp();
<a name="l01469"></a>01469  vectorH = up.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l01470"></a>01470  vectorV = vectorH.<a class="code" href="classVPVector3D.html#a19">vpCrossProduct</a>(projectionDirection);
<a name="l01471"></a>01471 
<a name="l01472"></a>01472  <span class="comment">// Set scan window corner (where the scan begin)</span>
<a name="l01473"></a>01473  minPlaneProjection = (location - vectorH*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/2));
<a name="l01474"></a>01474  minPlaneProjection = (minPlaneProjection - vectorV*(winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/2));
<a name="l01475"></a>01475 
<a name="l01476"></a>01476  <span class="comment">// Set variables to determine the end of the view scan</span>
<a name="l01477"></a>01477  finalLineValue = camera-&gt;vpGetViewHeight();
<a name="l01478"></a>01478  finalColumnValue = camera-&gt;vpGetViewWidth();
<a name="l01479"></a>01479 
<a name="l01480"></a>01480  <span class="comment">// To verify the ratio between the window and the view</span>
<a name="l01481"></a>01481  <span class="comment">// greater window dimension / view dimension (where viewx=viewy)</span>
<a name="l01482"></a>01482  <span class="keywordflow">if</span> (winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() &gt; winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()) {
<a name="l01483"></a>01483     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / finalColumnValue;
<a name="l01484"></a>01484     finalLineValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / auxRatio;
<a name="l01485"></a>01485     imageYdelta = (camera-&gt;vpGetViewHeight() - finalLineValue) / 2;
<a name="l01486"></a>01486  }
<a name="l01487"></a>01487  <span class="keywordflow">else</span> {
<a name="l01488"></a>01488     auxRatio = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>() / finalLineValue;
<a name="l01489"></a>01489     finalColumnValue = winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>() / auxRatio;
<a name="l01490"></a>01490     imageXdelta = (camera-&gt;vpGetViewWidth() - finalColumnValue) / 2;
<a name="l01491"></a>01491  }
<a name="l01492"></a>01492 
<a name="l01493"></a>01493  <span class="comment">// To verify the smallest dimension and set the virtualVolumeDimension</span>
<a name="l01494"></a>01494  <span class="keywordflow">if</span> ( ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension() &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension() )
<a name="l01495"></a>01495     virtualYDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension();
<a name="l01496"></a>01496  <span class="keywordflow">else</span> 
<a name="l01497"></a>01497     virtualYDimension = ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension(); 
<a name="l01498"></a>01498  yCorrection = ((float) ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) / ((float) virtualYDimension);
<a name="l01499"></a>01499 
<a name="l01500"></a>01500  <span class="comment">// Window/Viewport ratio</span>
<a name="l01501"></a>01501  ratioX =  winTopRightValue.<a class="code" href="classVPPoint2D.html#a2">vpGetX</a>()/finalColumnValue;
<a name="l01502"></a>01502  ratioY = winTopRightValue.<a class="code" href="classVPPoint2D.html#a3">vpGetY</a>()/finalLineValue;
<a name="l01503"></a>01503 
<a name="l01504"></a>01504  <span class="comment">// Line, column and sample step </span>
<a name="l01505"></a>01505  deltaX = vectorH * ratioX;
<a name="l01506"></a>01506  deltaY = vectorV * ratioY;
<a name="l01507"></a>01507  deltaZ = projectionDirection.<a class="code" href="classVPVector3D.html#a20">vpModule</a>();
<a name="l01508"></a>01508  
<a name="l01510"></a>01510  <span class="comment">// Inner structures visualization parameters</span>
<a name="l01511"></a>01511  <span class="comment">// Goal: exhibition of two points (end of S-Band and T-Band), </span>
<a name="l01512"></a>01512  <span class="comment">//       a line that join them, and a line that identify</span>
<a name="l01513"></a>01513  <span class="comment">//       the ROI (where data will be sampled)</span>
<a name="l01514"></a>01514 
<a name="l01515"></a>01515  <span class="comment">// Necessary variables to set the S-Band and T-Band position in the image</span>
<a name="l01516"></a>01516  <a class="code" href="classVPPoint3D.html">VPPoint3D</a> SBand, TBand, center = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetCenterFocalPoint();  
<a name="l01517"></a>01517  <span class="keywordtype">bool</span> findPoint;
<a name="l01518"></a>01518  <span class="keywordtype">int</span> aux=0, arrayDimension, edgeComparison,
<a name="l01519"></a>01519      xDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetXDimension(),
<a name="l01520"></a>01520      yDimension = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetYDimension();
<a name="l01521"></a>01521  <span class="keywordtype">int</span> edge=0, SBandSteps=0, TBandSteps=0;
<a name="l01522"></a>01522 
<a name="l01523"></a>01523  <span class="comment">// To set arrayDimension (slice diagonal)</span>
<a name="l01524"></a>01524   arrayDimension = (int) ( sqrt( (xDimension*xDimension) + (yDimension*yDimension) ) / 2.0 + 1.0 );
<a name="l01525"></a>01525 
<a name="l01526"></a>01526  <span class="comment">// round value</span>
<a name="l01527"></a>01527  SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01528"></a>01528  SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01529"></a>01529  SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingSBand();
<a name="l01530"></a>01530  TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01531"></a>01531  TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (center.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01532"></a>01532  TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetRayCastingTBand();
<a name="l01533"></a>01533 
<a name="l01534"></a>01534  <span class="comment">// Process the steps between the edge and SBand and between</span>
<a name="l01535"></a>01535  <span class="comment">// SBand and TBand (using the "middle slice")</span>
<a name="l01536"></a>01536  edge = 0;
<a name="l01537"></a>01537  <span class="keywordflow">while</span> (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>,SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>,edge) &lt;= 40) 
<a name="l01538"></a>01538      edge++;
<a name="l01539"></a>01539  SBandSteps = SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - edge;
<a name="l01540"></a>01540  TBandSteps = TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> - SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>;
<a name="l01541"></a>01541 
<a name="l01543"></a>01543  <span class="comment">// First: find the lineSBand and lineTBand points</span>
<a name="l01544"></a>01544  <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>=0;
<a name="l01545"></a>01545  <span class="keywordflow">if</span> (<a class="code" href="classVPSlice.html#p2">lineSBand</a> != <a class="code" href="RasDefine_8h.html#a0">NULL</a>) {
<a name="l01546"></a>01546     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l01547"></a>01547     <span class="keyword">delete</span> [] <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l01548"></a>01548  }
<a name="l01549"></a>01549  <a class="code" href="classVPSlice.html#p2">lineSBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l01550"></a>01550  <a class="code" href="classVPSlice.html#p3">lineTBand</a> = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arrayDimension];
<a name="l01551"></a>01551 
<a name="l01552"></a>01552  <span class="comment">// Find object edge at "SBand column"</span>
<a name="l01553"></a>01553  edge = 0;
<a name="l01554"></a>01554  edgeComparison = 0.8 * yDimension; <span class="comment">// 80%</span>
<a name="l01555"></a>01555  <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>,edge,sliceNumber) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) )
<a name="l01556"></a>01556     edge++;
<a name="l01557"></a>01557  <span class="keywordflow">if</span> ( edge &lt; edgeComparison )
<a name="l01558"></a>01558     edgeComparison = 1;
<a name="l01559"></a>01559  <span class="keywordflow">else</span>
<a name="l01560"></a>01560     edgeComparison = 0;
<a name="l01561"></a>01561  
<a name="l01562"></a>01562  <span class="comment">// For the case of a very dark slice (top or bottom slice)</span>
<a name="l01563"></a>01563  <span class="keywordflow">if</span> ( edgeComparison )
<a name="l01564"></a>01564  { 
<a name="l01565"></a>01565      <span class="comment">// New SBand and TBand in accordance with scan direction</span>
<a name="l01566"></a>01566      nextPoint = volumeCameraLocation;
<a name="l01567"></a>01567      nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a> = sliceNumber;
<a name="l01568"></a>01568      <a class="code" href="classVPSlice.html#a13">vpFindPntInsideFrontalSlice</a>(nextPoint, scanDirection, xDimension, yDimension);
<a name="l01569"></a>01569      <span class="keywordflow">if</span> ( ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &gt;= 10 )
<a name="l01570"></a>01570      { <span class="comment">// if the point is already inside the volume, it's necessary to find "the limit"</span>
<a name="l01571"></a>01571          <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;xDimension-1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;yDimension-1) )
<a name="l01572"></a>01572             nextPoint = nextPoint - scanDirection;
<a name="l01573"></a>01573      }
<a name="l01574"></a>01574      <span class="keywordflow">while</span> ( ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40 )
<a name="l01575"></a>01575         nextPoint = nextPoint + scanDirection;
<a name="l01576"></a>01576      
<a name="l01577"></a>01577      SBand = nextPoint;
<a name="l01578"></a>01578 
<a name="l01579"></a>01579      <span class="keywordflow">for</span> (i=0; i&lt;SBandSteps; i++)
<a name="l01580"></a>01580          SBand = SBand + scanDirection;
<a name="l01581"></a>01581         
<a name="l01582"></a>01582      TBand = SBand;
<a name="l01583"></a>01583 
<a name="l01584"></a>01584      <span class="keywordflow">for</span> (i=0; i&lt;TBandSteps; i++)
<a name="l01585"></a>01585          TBand = TBand + scanDirection;
<a name="l01586"></a>01586         
<a name="l01587"></a>01587      <span class="comment">// round value</span>
<a name="l01588"></a>01588      SBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01589"></a>01589      SBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01590"></a>01590      SBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (SBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l01591"></a>01591      TBand.<a class="code" href="classVPPoint3D.html#o0">x</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o0">x</a>+0.5);
<a name="l01592"></a>01592      TBand.<a class="code" href="classVPPoint3D.html#o1">y</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o1">y</a>+0.5);
<a name="l01593"></a>01593      TBand.<a class="code" href="classVPPoint3D.html#o2">z</a> = (int) (TBand.<a class="code" href="classVPPoint3D.html#o2">z</a>+0.5);
<a name="l01594"></a>01594 
<a name="l01595"></a>01595      <span class="comment">// lineScan to find the positions at scanDirection</span>
<a name="l01596"></a>01596      <span class="comment">// (from the center to left, and from the center to right)</span>
<a name="l01597"></a>01597      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = SBand.<a class="code" href="classVPPoint3D.html#o0">x</a>;
<a name="l01598"></a>01598      <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = SBand.<a class="code" href="classVPPoint3D.html#o1">y</a>;
<a name="l01599"></a>01599      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = TBand.<a class="code" href="classVPPoint3D.html#o0">x</a>;          
<a name="l01600"></a>01600      <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = TBand.<a class="code" href="classVPPoint3D.html#o1">y</a>;
<a name="l01601"></a>01601      findPoint = <span class="keyword">true</span>;
<a name="l01602"></a>01602      <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01603"></a>01603 
<a name="l01604"></a>01604      nextLinePoint = volumeCameraLocation;
<a name="l01605"></a>01605      nextLinePoint.<a class="code" href="classVPPoint3D.html#o2">z</a> = sliceNumber;
<a name="l01606"></a>01606 
<a name="l01607"></a>01607      <span class="comment">// First, process "right" points</span>
<a name="l01608"></a>01608      <span class="keywordflow">while</span> (findPoint) {
<a name="l01609"></a>01609         nextLinePoint = nextLinePoint + lineScan + lineScan; <span class="comment">// next point after SBand in line scan</span>
<a name="l01610"></a>01610         nextPoint = nextLinePoint;
<a name="l01611"></a>01611         <a class="code" href="classVPSlice.html#a13">vpFindPntInsideFrontalSlice</a>(nextPoint, scanDirection, xDimension, yDimension);
<a name="l01612"></a>01612         
<a name="l01613"></a>01613         <span class="comment">// if the point is already inside the volume, it's necessary to find "the limit"</span>
<a name="l01614"></a>01614         <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;xDimension-1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;yDimension-1) )
<a name="l01615"></a>01615             nextPoint = nextPoint - scanDirection;
<a name="l01616"></a>01616 
<a name="l01617"></a>01617         edge = 0;
<a name="l01618"></a>01618         edgeComparison = 0.8 * yDimension; <span class="comment">// 80%</span>
<a name="l01619"></a>01619         <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) ) 
<a name="l01620"></a>01620         {
<a name="l01621"></a>01621             nextPoint = nextPoint + scanDirection;
<a name="l01622"></a>01622             edge++;
<a name="l01623"></a>01623             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension) )
<a name="l01624"></a>01624                 <span class="keywordflow">break</span>;
<a name="l01625"></a>01625         }
<a name="l01626"></a>01626         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension))
<a name="l01627"></a>01627                 edgeComparison = 0;
<a name="l01628"></a>01628         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l01629"></a>01629                     edgeComparison = 1;
<a name="l01630"></a>01630                 <span class="keywordflow">else</span> 
<a name="l01631"></a>01631                     edgeComparison = 0;
<a name="l01632"></a>01632 
<a name="l01633"></a>01633         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// if the column "hit the volume"</span>
<a name="l01634"></a>01634             <span class="comment">// nextPoint is 3D, but z is the selected slice </span>
<a name="l01635"></a>01635             <span class="comment">// lineSBand is 2D; since z is always the same, x=nextPoint.x and y=nextPoint.y (the point in the "slice plane")</span>
<a name="l01636"></a>01636             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a> + (SBandSteps * scanDirection.x);
<a name="l01637"></a>01637             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a> + (SBandSteps * scanDirection.y); 
<a name="l01638"></a>01638             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.x);
<a name="l01639"></a>01639             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.y); 
<a name="l01640"></a>01640             
<a name="l01641"></a>01641             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01642"></a>01642         }
<a name="l01643"></a>01643         <span class="keywordflow">else</span> { <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l01644"></a>01644             findPoint = <span class="keyword">false</span>;  
<a name="l01645"></a>01645             aux = <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>;
<a name="l01646"></a>01646         }
<a name="l01647"></a>01647      } <span class="comment">// while</span>
<a name="l01648"></a>01648      findPoint = <span class="keyword">true</span>;
<a name="l01649"></a>01649      nextLinePoint = volumeCameraLocation;
<a name="l01650"></a>01650      nextLinePoint.<a class="code" href="classVPPoint3D.html#o2">z</a> = sliceNumber;
<a name="l01651"></a>01651      nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l01652"></a>01652      nextPoint = nextLinePoint;
<a name="l01653"></a>01653      <a class="code" href="classVPSlice.html#a13">vpFindPntInsideFrontalSlice</a>(nextPoint, scanDirection, xDimension, yDimension);
<a name="l01654"></a>01654 
<a name="l01655"></a>01655      <span class="comment">// Second, process "left" points</span>
<a name="l01656"></a>01656      <span class="keywordflow">while</span> (findPoint) {
<a name="l01657"></a>01657         edge = 0;
<a name="l01658"></a>01658         edgeComparison = 0.8 * yDimension; <span class="comment">// 80%</span>
<a name="l01659"></a>01659 
<a name="l01660"></a>01660         <span class="comment">// if the point is already inside the volume, it's necessary to find "the limit"</span>
<a name="l01661"></a>01661         <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;xDimension-1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;yDimension-1) )
<a name="l01662"></a>01662             nextPoint = nextPoint - scanDirection;
<a name="l01663"></a>01663         
<a name="l01664"></a>01664         <span class="keywordflow">while</span> ( (((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>,nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>) &lt;= 40) &amp;&amp; (edge&lt;=edgeComparison) ) 
<a name="l01665"></a>01665         {
<a name="l01666"></a>01666             nextPoint = nextPoint + scanDirection;
<a name="l01667"></a>01667             edge++;
<a name="l01668"></a>01668             <span class="keywordflow">if</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension) )
<a name="l01669"></a>01669                 <span class="keywordflow">break</span>;
<a name="l01670"></a>01670         }
<a name="l01671"></a>01671         <span class="keywordflow">if</span> ((nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension))
<a name="l01672"></a>01672                 edgeComparison = 0;
<a name="l01673"></a>01673         <span class="keywordflow">else</span>    <span class="keywordflow">if</span> ( edge &lt;= edgeComparison )
<a name="l01674"></a>01674                     edgeComparison = 1;
<a name="l01675"></a>01675                 <span class="keywordflow">else</span> 
<a name="l01676"></a>01676                     edgeComparison = 0;
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         <span class="keywordflow">if</span> ( edgeComparison ) { <span class="comment">// the column "hit the volume"</span>
<a name="l01679"></a>01679 
<a name="l01680"></a>01680             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a> + (SBandSteps * scanDirection.x);
<a name="l01681"></a>01681             <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a> + (SBandSteps * scanDirection.y); 
<a name="l01682"></a>01682             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o0">x</a> + (TBandSteps * scanDirection.x);
<a name="l01683"></a>01683             <a class="code" href="classVPSlice.html#p3">lineTBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>].<a class="code" href="classVPPoint2D.html#o1">y</a> + (TBandSteps * scanDirection.y); 
<a name="l01684"></a>01684             nextLinePoint = nextLinePoint - lineScan - lineScan; <span class="comment">// "next point" before SBand in line scan</span>
<a name="l01685"></a>01685             nextPoint = nextLinePoint;
<a name="l01686"></a>01686             <a class="code" href="classVPSlice.html#a13">vpFindPntInsideFrontalSlice</a>(nextPoint, scanDirection, xDimension, yDimension);
<a name="l01687"></a>01687 
<a name="l01688"></a>01688             <span class="comment">// if the point is already inside the volume, it's necessary to find "the limit"</span>
<a name="l01689"></a>01689             <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;xDimension-1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;1) &amp;&amp; (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;yDimension-1) )
<a name="l01690"></a>01690                 nextPoint = nextPoint - scanDirection;
<a name="l01691"></a>01691             
<a name="l01692"></a>01692             <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>++;
<a name="l01693"></a>01693         }
<a name="l01694"></a>01694         <span class="keywordflow">else</span> <span class="comment">// the column doesn't "hit the volume"</span>
<a name="l01695"></a>01695             findPoint = <span class="keyword">false</span>;  
<a name="l01696"></a>01696      }
<a name="l01697"></a>01697  }
<a name="l01698"></a>01698 
<a name="l01699"></a>01699  <a class="code" href="classVPSlice.html#a14">vpOrder</a>(arrayDimension, <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>, aux);
<a name="l01700"></a>01700 
<a name="l01702"></a>01702  <span class="comment">// Scan view line for the ray casting </span>
<a name="l01703"></a>01703 
<a name="l01704"></a>01704  <span class="keywordflow">for</span> (line=0; line&lt;finalLineValue; line++) { 
<a name="l01705"></a>01705 
<a name="l01706"></a>01706      <span class="comment">// Plane point computation</span>
<a name="l01707"></a>01707      p1 = minPlaneProjection;
<a name="l01708"></a>01708      p1 = p1 + deltaY * line; 
<a name="l01709"></a>01709      p1.<a class="code" href="classVPPoint3D.html#o1">y</a> = p1.<a class="code" href="classVPPoint3D.html#o1">y</a>*yCorrection;
<a name="l01710"></a>01710 
<a name="l01711"></a>01711      <span class="comment">// Scan view column</span>
<a name="l01712"></a>01712      <span class="keywordflow">for</span> (column=0; column&lt;finalColumnValue; column++) {
<a name="l01713"></a>01713 
<a name="l01714"></a>01714         i = (int) (p1.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>()); <span class="comment">//(column);</span>
<a name="l01715"></a>01715         j = (int) (p1.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>()); <span class="comment">//(line);</span>
<a name="l01716"></a>01716         k = sliceNumber; <span class="comment">//(depth);</span>
<a name="l01717"></a>01717 
<a name="l01718"></a>01718         p1.<a class="code" href="classVPPoint3D.html#a14">vpSetZ</a>(sliceNumber);
<a name="l01719"></a>01719         voxelColor = <a class="code" href="classVPSlice.html#a15">vpTrilinearInterpolation</a>(i,j,k,volume,p1);
<a name="l01720"></a>01720 
<a name="l01721"></a>01721         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a11">red</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01722"></a>01722         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a12">green</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01723"></a>01723         image[line+imageYdelta][column+imageXdelta][<a class="code" href="vpvolume_8h.html#a13">blue</a>] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> int) voxelColor;
<a name="l01724"></a>01724 
<a name="l01725"></a>01725         <span class="comment">// Next plane point computation</span>
<a name="l01726"></a>01726         p1 = p1 + deltaX; 
<a name="l01727"></a>01727 
<a name="l01728"></a>01728     } <span class="comment">// for (column)</span>
<a name="l01729"></a>01729 
<a name="l01730"></a>01730  } <span class="comment">// for (line)</span>
<a name="l01731"></a>01731 
<a name="l01732"></a>01732  <span class="comment">// Mapping endOfSBand and endOfTBand from the window to the viewport</span>
<a name="l01733"></a>01733  auxFloat = <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01734"></a>01734  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a>-yDimension)) / yDimension + finalLineValue;
<a name="l01735"></a>01735  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-xDimension)) / -xDimension );
<a name="l01736"></a>01736  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01737"></a>01737  <a class="code" href="classVPSlice.html#p0">endOfSBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01738"></a>01738  auxFloat = <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01739"></a>01739  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a>-yDimension)) / yDimension + finalLineValue;
<a name="l01740"></a>01740  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-xDimension)) / -xDimension );
<a name="l01741"></a>01741  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01742"></a>01742  <a class="code" href="classVPSlice.html#p1">endOfTBand</a>.<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01743"></a>01743 
<a name="l01744"></a>01744  <span class="comment">// Mapping lineTBand and lineSBand points from the window to the viewport</span>
<a name="l01745"></a>01745  <span class="keywordflow">for</span> (cont=0; cont&lt;<a class="code" href="classVPSlice.html#p4">numTotalPoints</a>; cont++) {
<a name="l01746"></a>01746     auxFloat = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01747"></a>01747     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a>-yDimension)) / yDimension + finalLineValue;
<a name="l01748"></a>01748     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-xDimension)) / -xDimension );
<a name="l01749"></a>01749     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01750"></a>01750     <a class="code" href="classVPSlice.html#p3">lineTBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752     auxFloat = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01753"></a>01753     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> = (finalLineValue*(<a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a>-yDimension)) / yDimension + finalLineValue;
<a name="l01754"></a>01754     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> = ( (finalColumnValue*(auxFloat-xDimension)) / -xDimension );
<a name="l01755"></a>01755     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o0">x</a> += imageYdelta;
<a name="l01756"></a>01756     <a class="code" href="classVPSlice.html#p2">lineSBand</a>[cont].<a class="code" href="classVPPoint2D.html#o1">y</a> += imageXdelta;
<a name="l01757"></a>01757  }
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 }
<a name="l01760"></a>01760 
<a name="l01761"></a>01761 
<a name="l01763"></a>01763 <span class="comment">// Description: Method "vpFindPointInsideAxialSlice" guarante that </span>
<a name="l01764"></a>01764 <span class="comment">//              the point is inside a axial slice in the volume.</span>
<a name="l01765"></a>01765 <span class="comment">// Parameters.: VPPoint3D nextPoint (point inside the volume)</span>
<a name="l01766"></a>01766 <span class="comment">//              VPVector3D scanDirection (direction to find the point)</span>
<a name="l01767"></a>01767 <span class="comment">//              int xDimension (x volume dimension)</span>
<a name="l01768"></a>01768 <span class="comment">//              int zDimension (z volume dimension)</span>
<a name="l01769"></a>01769 <span class="comment">// Return.....: -</span>
<a name="l01770"></a>01770 
<a name="l01771"></a><a class="code" href="classVPSlice.html#a11">01771</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a11">VPSlice::vpFindPointInsideAxialSlice</a>(<a class="code" href="classVPPoint3D.html">VPPoint3D</a> &amp;nextPoint, <a class="code" href="classVPVector3D.html">VPVector3D</a> scanDirection, <span class="keywordtype">int</span> xDimension, <span class="keywordtype">int</span> zDimension) {
<a name="l01772"></a>01772     <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l01773"></a>01773             nextPoint = nextPoint + scanDirection;
<a name="l01774"></a>01774 }
<a name="l01775"></a>01775 
<a name="l01776"></a>01776 
<a name="l01778"></a>01778 <span class="comment">// Description: Method "vpFindPntInsideSagittalSlice" guarante that </span>
<a name="l01779"></a>01779 <span class="comment">//              the point is inside a sagittal slice in the volume.</span>
<a name="l01780"></a>01780 <span class="comment">// Parameters.: VPPoint3D nextPoint (point inside the volume)</span>
<a name="l01781"></a>01781 <span class="comment">//              VPVector3D scanDirection (direction to find the point)</span>
<a name="l01782"></a>01782 <span class="comment">//              int yDimension (y volume dimension)</span>
<a name="l01783"></a>01783 <span class="comment">//              int zDimension (z volume dimension)</span>
<a name="l01784"></a>01784 <span class="comment">// Return.....: -</span>
<a name="l01785"></a>01785 
<a name="l01786"></a><a class="code" href="classVPSlice.html#a12">01786</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a12">VPSlice::vpFindPntInsideSagittalSlice</a>(<a class="code" href="classVPPoint3D.html">VPPoint3D</a> &amp;nextPoint, <a class="code" href="classVPVector3D.html">VPVector3D</a> scanDirection, <span class="keywordtype">int</span> yDimension, <span class="keywordtype">int</span> zDimension) {
<a name="l01787"></a>01787     <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o2">z</a>&gt;=zDimension) )
<a name="l01788"></a>01788             nextPoint = nextPoint + scanDirection;
<a name="l01789"></a>01789 }
<a name="l01790"></a>01790 
<a name="l01791"></a>01791 
<a name="l01793"></a>01793 <span class="comment">// Description: Method "vpFindPntInsideFrontalSlice" guarante that </span>
<a name="l01794"></a>01794 <span class="comment">//              the point is inside a frontal slice in the volume.</span>
<a name="l01795"></a>01795 <span class="comment">// Parameters.: VPPoint3D nextPoint (point inside the volume)</span>
<a name="l01796"></a>01796 <span class="comment">//              VPVector3D scanDirection (direction to find the point)</span>
<a name="l01797"></a>01797 <span class="comment">//              int xDimension (x volume dimension)</span>
<a name="l01798"></a>01798 <span class="comment">//              int yDimension (y volume dimension)</span>
<a name="l01799"></a>01799 <span class="comment">// Return.....: -</span>
<a name="l01800"></a>01800 
<a name="l01801"></a><a class="code" href="classVPSlice.html#a13">01801</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a13">VPSlice::vpFindPntInsideFrontalSlice</a>(<a class="code" href="classVPPoint3D.html">VPPoint3D</a> &amp;nextPoint, <a class="code" href="classVPVector3D.html">VPVector3D</a> scanDirection, <span class="keywordtype">int</span> xDimension, <span class="keywordtype">int</span> yDimension) {
<a name="l01802"></a>01802     <span class="keywordflow">while</span> ( (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o0">x</a>&gt;=xDimension) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&lt;0) || (nextPoint.<a class="code" href="classVPPoint3D.html#o1">y</a>&gt;=yDimension) )
<a name="l01803"></a>01803             nextPoint = nextPoint + scanDirection;
<a name="l01804"></a>01804 }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 
<a name="l01808"></a>01808 <span class="comment">// Description: Method "vpOrder" "put in order" the points of the</span>
<a name="l01809"></a>01809 <span class="comment">//              lineSBand and lineTBand arrays.</span>
<a name="l01810"></a>01810 <span class="comment">// Parameters.: int arraySize, to alloc a temporary array (same </span>
<a name="l01811"></a>01811 <span class="comment">//                             size as lineTBand and lineSBand)</span>
<a name="l01812"></a>01812 <span class="comment">//              int numTotalPoints (arrays total points) </span>
<a name="l01813"></a>01813 <span class="comment">//              int aux (middle point, separate left and right</span>
<a name="l01814"></a>01814 <span class="comment">//                       points from SBand and TBand) </span>
<a name="l01815"></a>01815 <span class="comment">// Return.....: -</span>
<a name="l01816"></a>01816 
<a name="l01817"></a><a class="code" href="classVPSlice.html#a14">01817</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a14">VPSlice::vpOrder</a>(<span class="keywordtype">int</span> arraySize, <span class="keywordtype">int</span> numTotalPoints, <span class="keywordtype">int</span> aux)
<a name="l01818"></a>01818 {
<a name="l01819"></a>01819  <a class="code" href="classVPPoint2D.html">VPPoint2D</a> *auxLine, *auxPointer; 
<a name="l01820"></a>01820  <span class="keywordtype">int</span> i, j;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822  auxLine = <span class="keyword">new</span> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> [<span class="keyword">sizeof</span>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a>) * arraySize];
<a name="l01823"></a>01823 
<a name="l01824"></a>01824  <span class="keywordflow">for</span> (i=numTotalPoints-1, j=0; i&gt;=aux; i--, j++) {
<a name="l01825"></a>01825     auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[i].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01826"></a>01826     auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[i].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01827"></a>01827  }
<a name="l01828"></a>01828  auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[0].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01829"></a>01829  auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[0].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01830"></a>01830  j++;
<a name="l01831"></a>01831  <span class="keywordflow">for</span> (i=1; i&lt;aux; i++, j++) {
<a name="l01832"></a>01832     auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[i].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01833"></a>01833     auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p2">lineSBand</a>[i].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01834"></a>01834  }
<a name="l01835"></a>01835 
<a name="l01836"></a>01836  auxPointer = <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l01837"></a>01837  <a class="code" href="classVPSlice.html#p2">lineSBand</a> = auxLine;
<a name="l01838"></a>01838  auxLine = auxPointer;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840  <span class="keywordflow">for</span> (i=numTotalPoints-1, j=0; i&gt;=aux; i--, j++) {
<a name="l01841"></a>01841     auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[i].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01842"></a>01842     auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[i].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01843"></a>01843  }
<a name="l01844"></a>01844  auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[0].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01845"></a>01845  auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[0].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01846"></a>01846  j++;
<a name="l01847"></a>01847  <span class="keywordflow">for</span> (i=1; i&lt;aux; i++, j++) {
<a name="l01848"></a>01848     auxLine[j].<a class="code" href="classVPPoint2D.html#o0">x</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[i].<a class="code" href="classVPPoint2D.html#o0">x</a>;
<a name="l01849"></a>01849     auxLine[j].<a class="code" href="classVPPoint2D.html#o1">y</a> = <a class="code" href="classVPSlice.html#p3">lineTBand</a>[i].<a class="code" href="classVPPoint2D.html#o1">y</a>;
<a name="l01850"></a>01850  }
<a name="l01851"></a>01851 
<a name="l01852"></a>01852  auxPointer = <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l01853"></a>01853  <a class="code" href="classVPSlice.html#p3">lineTBand</a> = auxLine;
<a name="l01854"></a>01854 
<a name="l01855"></a>01855  <span class="keyword">delete</span> [] auxPointer;
<a name="l01856"></a>01856 }
<a name="l01857"></a>01857     
<a name="l01858"></a>01858 
<a name="l01860"></a>01860 <span class="comment">// Description: Method "vpTrilinearInterpolation" process the voxel </span>
<a name="l01861"></a>01861 <span class="comment">//              color (gray) using trilinear interpolation.</span>
<a name="l01862"></a>01862 <span class="comment">// Parameters.: int i, int j, int k, VPGraphicObj *volume,</span>
<a name="l01863"></a>01863 <span class="comment">//              float increment (i,j,k=volume matrix index; </span>
<a name="l01864"></a>01864 <span class="comment">//              depth=ray position; volume=object volume that has all </span>
<a name="l01865"></a>01865 <span class="comment">//              information about the volume; increment=increment step</span>
<a name="l01866"></a>01866 <span class="comment">//              in the ray) </span>
<a name="l01867"></a>01867 <span class="comment">// Return.....: float color (voxel color)</span>
<a name="l01868"></a>01868 
<a name="l01869"></a><a class="code" href="classVPSlice.html#a15">01869</a> <span class="keywordtype">float</span> <a class="code" href="classVPSlice.html#a15">VPSlice::vpTrilinearInterpolation</a>(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> k,  
<a name="l01870"></a>01870                                              <a class="code" href="classVPGraphicObj.html">VPGraphicObj</a> *volume, <a class="code" href="classVPPoint3D.html">VPPoint3D</a> p) {
<a name="l01871"></a>01871 
<a name="l01872"></a>01872  <span class="keywordtype">int</span> C1, C2, C3, C4, C5, C6, C7, C8, ii, jj, kk;
<a name="l01873"></a>01873  <span class="keywordtype">float</span> i1, i2, i3, i4, i5, i6, i7,  <span class="comment">// valores interpolados</span>
<a name="l01874"></a>01874        dx, dy, dz;                  <span class="comment">// distncia (delta)</span>
<a name="l01875"></a>01875 
<a name="l01876"></a>01876  <span class="comment">// First, voxels color initialization</span>
<a name="l01877"></a>01877  ii = ((i+1) &lt; ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetXDimension()) ? i+1 : i;
<a name="l01878"></a>01878  jj = ((j+1) &lt; ((<a class="code" href="classVPImage.html">VPImage</a> *)volume)-&gt;vpGetYDimension()) ? j+1 : j;
<a name="l01879"></a>01879  kk = ((k+1) &lt; ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetZDimension()) ? k+1 : k;
<a name="l01880"></a>01880  C1 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(i,j,k);
<a name="l01881"></a>01881  C2 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(ii,j,k);
<a name="l01882"></a>01882  C3 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(ii,jj,k);
<a name="l01883"></a>01883  C4 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(i,jj,k);
<a name="l01884"></a>01884  C5 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(i,j,kk);
<a name="l01885"></a>01885  C6 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(ii,j,kk);
<a name="l01886"></a>01886  C7 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(ii,jj,kk);
<a name="l01887"></a>01887  C8 = ((<a class="code" href="classVPVolume.html">VPVolume</a> *)volume)-&gt;vpGetValue(i,jj,kk);
<a name="l01888"></a>01888  
<a name="l01889"></a>01889   <span class="comment">// If all voxels have the same color, it is not necessary to interpolate  </span>
<a name="l01890"></a>01890  <span class="keywordflow">if</span> ((C1==C2) &amp;&amp; (C2==C3) &amp;&amp; (C3==C4) &amp;&amp; (C4==C5) &amp;&amp; (C5==C6) &amp;&amp; (C6==C7) &amp;&amp; (C7==C8))
<a name="l01891"></a>01891     <span class="keywordflow">return</span>( (float)(C1) );
<a name="l01892"></a>01892 
<a name="l01893"></a>01893  <span class="comment">// Trilinear interpolation (seven linear interpolations)</span>
<a name="l01894"></a>01894  <span class="comment">//                 </span>
<a name="l01895"></a>01895  <span class="comment">//       5-----------------6       </span>
<a name="l01896"></a>01896  <span class="comment">//      /|                /|       </span>
<a name="l01897"></a>01897  <span class="comment">//     i1-------i5-------i2|       </span>
<a name="l01898"></a>01898  <span class="comment">//    /  |      |       /  |       </span>
<a name="l01899"></a>01899  <span class="comment">//   1-----------------2   |       </span>
<a name="l01900"></a>01900  <span class="comment">//   |   |      |      |   |       </span>
<a name="l01901"></a>01901  <span class="comment">//   |   |      i7     |   |       </span>
<a name="l01902"></a>01902  <span class="comment">//   |   |      |      |   |       </span>
<a name="l01903"></a>01903  <span class="comment">//   |   8------|i3----|---7       </span>
<a name="l01904"></a>01904  <span class="comment">//   |  /       |/     |  /        </span>
<a name="l01905"></a>01905  <span class="comment">//   | /        i6     | /     </span>
<a name="l01906"></a>01906  <span class="comment">//   |/        /       |/      </span>
<a name="l01907"></a>01907  <span class="comment">//   4--------i4-------3       </span>
<a name="l01908"></a>01908  <span class="comment">//                 </span>
<a name="l01909"></a>01909 
<a name="l01910"></a>01910  <span class="comment">// Distance from the voxel 1</span>
<a name="l01911"></a>01911  dx = p.<a class="code" href="classVPPoint3D.html#a2">vpGetX</a>()-i;
<a name="l01912"></a>01912  dy = p.<a class="code" href="classVPPoint3D.html#a3">vpGetY</a>()-j;
<a name="l01913"></a>01913  dz = p.<a class="code" href="classVPPoint3D.html#a4">vpGetZ</a>()-k;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915  <span class="comment">// Interpolation values</span>
<a name="l01916"></a>01916  i1 = ( (C5-C1) * dz + C1);
<a name="l01917"></a>01917  i2 = ( (C6-C2) * dz + C2);
<a name="l01918"></a>01918  i3 = ( (C7-C8) * dx + C8);
<a name="l01919"></a>01919  i4 = ( (C3-C4) * dx + C4);
<a name="l01920"></a>01920  i5 = ( (i2-i1) * dx + i1);
<a name="l01921"></a>01921  i6 = ( (i3-i4) * dz + i4);
<a name="l01922"></a>01922  i7 = ( (i6-i5) * dy + i5);
<a name="l01923"></a>01923 
<a name="l01924"></a>01924  <span class="keywordflow">return</span>(i7);
<a name="l01925"></a>01925 }
<a name="l01926"></a>01926 
<a name="l01927"></a>01927 
<a name="l01929"></a>01929 <span class="comment">// Description: Method "vpGetViewSBandPoint" returns the value of </span>
<a name="l01930"></a>01930 <span class="comment">//              endOfSBand attribute.</span>
<a name="l01931"></a>01931 <span class="comment">// Parameters.: -</span>
<a name="l01932"></a>01932 <span class="comment">// Return.....: VPPoint2D endOfSBand (attribute value)</span>
<a name="l01933"></a>01933 
<a name="l01934"></a><a class="code" href="classVPSlice.html#a16">01934</a> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> <a class="code" href="classVPSlice.html#a16">VPSlice::vpGetViewSBandPoint</a>() {
<a name="l01935"></a>01935     <span class="keywordflow">return</span> <a class="code" href="classVPSlice.html#p0">endOfSBand</a>; <span class="comment">// endOfSBand;</span>
<a name="l01936"></a>01936 }
<a name="l01937"></a>01937 
<a name="l01938"></a>01938 
<a name="l01940"></a>01940 <span class="comment">// Description: Method "vpGetViewTBandPoint" returns the value of </span>
<a name="l01941"></a>01941 <span class="comment">//              endOfTBand attribute.</span>
<a name="l01942"></a>01942 <span class="comment">// Parameters.: -</span>
<a name="l01943"></a>01943 <span class="comment">// Return.....: VPPoint2D endOfTBand (attribute value)</span>
<a name="l01944"></a>01944 
<a name="l01945"></a><a class="code" href="classVPSlice.html#a17">01945</a> <a class="code" href="classVPPoint2D.html">VPPoint2D</a> <a class="code" href="classVPSlice.html#a17">VPSlice::vpGetViewTBandPoint</a>() {
<a name="l01946"></a>01946     <span class="keywordflow">return</span> <a class="code" href="classVPSlice.html#p1">endOfTBand</a>; <span class="comment">// endOfTBand;</span>
<a name="l01947"></a>01947 }
<a name="l01948"></a>01948 
<a name="l01949"></a>01949 
<a name="l01951"></a>01951 <span class="comment">// Description: Method "vpGetLineSBand" returns the value of </span>
<a name="l01952"></a>01952 <span class="comment">//              lineSBand attribute and how many points it has.</span>
<a name="l01953"></a>01953 <span class="comment">// Parameters.: VPPoint2D *l, int &amp;n</span>
<a name="l01954"></a>01954 <span class="comment">// Return.....: -</span>
<a name="l01955"></a>01955 
<a name="l01956"></a><a class="code" href="classVPSlice.html#a18">01956</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a18">VPSlice::vpGetLineSBand</a>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a> **l, <span class="keywordtype">int</span> &amp;n) {
<a name="l01957"></a>01957     *l = <a class="code" href="classVPSlice.html#p2">lineSBand</a>;
<a name="l01958"></a>01958     n = <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>;
<a name="l01959"></a>01959 }
<a name="l01960"></a>01960 
<a name="l01961"></a>01961 
<a name="l01963"></a>01963 <span class="comment">// Description: Method "vpGetLineTBand" returns the value of </span>
<a name="l01964"></a>01964 <span class="comment">//              lineTBand attribute and how many points it has.</span>
<a name="l01965"></a>01965 <span class="comment">// Parameters.: VPPoint2D *l, int n</span>
<a name="l01966"></a>01966 <span class="comment">// Return.....: -</span>
<a name="l01967"></a>01967 
<a name="l01968"></a><a class="code" href="classVPSlice.html#a19">01968</a> <span class="keywordtype">void</span> <a class="code" href="classVPSlice.html#a19">VPSlice::vpGetLineTBand</a>(<a class="code" href="classVPPoint2D.html">VPPoint2D</a> **l, <span class="keywordtype">int</span> &amp;n) {
<a name="l01969"></a>01969     *l = <a class="code" href="classVPSlice.html#p3">lineTBand</a>;
<a name="l01970"></a>01970     n = <a class="code" href="classVPSlice.html#p4">numTotalPoints</a>;
<a name="l01971"></a>01971 }
<a name="l01972"></a>01972 
<a name="l01973"></a>01973 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Sep 6 10:00:06 2005 for VPAT by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
